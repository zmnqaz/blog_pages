<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[楼兰]]></title>
    <url>%2Fdiary%2Floulan.html</url>
    <content type="text"><![CDATA[一首歌卷起了我对爱情的追忆，可能我当时还不明白什么叫痛彻心扉。她叫楼兰。我们相识相忘只用了短短的四天，可就这四天对我来讲却又长得像一辈子。起初我来到她的班级，留下了联系方式。晚间时候，我收到一条陌生人短信：“你笑的很阳光”。于是我们的故事开始了。一天后我们见面了,那种青涩的隔阂很快便消失了。我们无话不谈，这四天里再也没什么能够阻止我们交流，恨不得不要睡觉。第二次见面在学校。一些特殊的原因从早忙到下午一点，还没咽下一口饭。烈日炎炎，困乏交加，仅存的一丝知觉便是要撑过晌午。随手给她发了一条信息，记忆已经模糊了，大致是说：”忙到忘记吃放，快要饿晕了。” 十分钟后她气喘吁吁的出现在我面前，手里拎着零食。那一瞬间，我的脑袋短路了。第三次见面是在图书馆，随后吃了点东西，最后送她回学校。公交车上站满了人，开的东倒西歪。我们相互贴的很近，那一刻我听见是两颗年轻心脏砰砰跳的的声音，或许这时的我们是相互属于彼此的。我克制住想要抱住她的冲动，只是腼腆的护她在身边。终于下车了，她用炙热的眼神跟我告白，待内心的火焰燃到顶点时，戏剧性的一幕发生了。她掐灭了这团火焰。 “我们的缘分来的太迟了！要是在去年的话…。可是这一切都来得太迟了，我已经背叛自己的爱情，绝不能跨出下一步了，刚才我很想就这样被你抱着，可是我很怕就这样被你抱住了。忘了我吧，忘了我这朵烂桃花吧。”递给我一本包着封面的书，扉页上写着“楼兰”。我看着她离去的背影，内心不知是什么滋味。从天堂到地狱不过如此吧。书签上留下了她的字迹：“与郎却喧暑，相忆莫相忘！”那晚我站在天台上，吹着从四面八方来的风，陷入了长长的失恋。想象着这样的场景，楼兰大漠，拖着我的尸体归去。这里没人哭泣，只剩下马革裹尸般的凄冷。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱我]]></title>
    <url>%2Fdiary%2Floveme.html</url>
    <content type="text"><![CDATA[曾经曾经，有人说爱我。有一首歌，《爱我》–张智成，有人说这是她的心境，是她的这些年，这是她。于是，我听完很想哭，我说年轻的心漂泊后才知孤独。何尝不想找一个人浪迹天涯，可是秋风已改画悲扇，锦书不再。禅修讲的是初，可是当我们翻山越岭，并肩齐行走中，却丢的一丝不挂，随风吹散。正想出家人出家为的是看破红尘不就是寻找初，所以一生只能望穿一条河流，忘不掉前世的初。那么心情沉重，不能领悟痛彻心扉，转变成极力想静静。可摆在眼前的是…无关的事，无关的人，异端突兀，就像悬在梁上的猫。终究在行走，穿过山川河海，寻找消失的恋人。2015.9.28var ap=new APlayer({element:document.getElementById("aplayer-dsIQScmR"),narrow:!1,autoplay:!0,showlrc:!1,music:{title:"爱我",author:"张智成",url:"https://imgs.lilonghua.top/%E7%88%B1%E6%88%91%20-%20%E5%BC%A0%E6%99%BA%E6%88%90.ogg",pic:"https://pic.xiami.net/images/album/img12/1212/1819353901381935390.jpg",lrc:""}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收录年少的我 2019]]></title>
    <url>%2Fdiary%2Fm2019.html</url>
    <content type="text"><![CDATA[续2018,今天是2018.7.28，故只有这些，也不打算再补了，有机会再整理吧。心事昨晚读 《暗时间》，十分畅快。可能这是我近些年来追求的东西。对于自我思考的人的崇拜，能够长篇累牍的写下自己对事物的看法，以及清晰秀丽的脑回路。刚回溯了一下过往几年有记录的文字表述。非常明显的发现，当一件事长时间不去付诸行动，那么自然而然的退化。迟迟的没有做的事，仍旧原地徘徊咯。我也不知道为了打翻这些岁月的空虚和寂寥。我都了做了些什么？2019.1.15我的城在农历2018消失殆尽之前，有幸读了林海音的《城南旧事》。一共分为三编。第一编讲的是童年的故事。第二编讲的事跟北平相关的经历和事物。第三编是零碎的小故事。头尾两编看了比较有感触。 中间的那编主要讲的是北平琐碎的记忆，因为我和北平半毛钱也打不上关系,所以读罢也就不知滋味。第一编的后记。解释了一下故事的情节和写作的目的，最后一句话非常的喜欢。”这里的几篇故事在时间上有点连贯性，读者们别再问我是真是假，我只要读者分享我一点缅怀童年的心情。每个人的童年都不是这样。余哀而神圣吗？”可能故事都非常的平凡而又普通。为了缅怀大家的童年，将自己的故事做了一些生动形象的改变，不也是很有乐趣吗？我不了解林海英是怎样的一个人，会不会是三岁看老呢？一想到如果人的一生最终会被写成一本书上。我想。最有趣的故事可能就是在童年吧，成年人的故事大多只是顺着前人的老路。故事只有童年不也是让人很唏嘘呢？我的童年的记忆大多已模糊不清，被时光给吞噬了。大部分和还是经由家人的口述，凭借着依稀的记忆，重构后才有这样清奇怪的印记。既然读的是城南旧时如此文艺的一本书。那么我也就厚着脸皮的。用上一个文艺的标题作序。我的城。小时候的我。在同学的面前是一个极其腼腆害羞的一个。小男孩。在父母面前却是一个暴君。后来慢慢的成长过程中就学会了，收拾起自己的脾气。我不是世界的中心，我是平凡的一个人，自卑而又傲娇。 有一本书叫做《自卑与超越》。2018.1.30 ps: 这段文字已经事语音转化而来的，文字上有很多顿挫感，最后也断了，好像是走在路上口述的，当时想如果能够记录脑电波的话，很多奇思妙想也不至于坐吃山空了。自命不凡应该是儿时的属性，成长让我们迷失了这一切。 19.2.24梦：梦见去茶山买了两张票，由于支付宝业务繁忙，售票小姐姐拿出微信，而微信支付是要先加好友的（梦中是这样的），于是就有联络的方式。上车时，她突然出现了，说是要和我一起去玩。（这是我买两张票的原因吗？解梦大师登场，哈哈。）Bus没来变成了金杯，上车后蹲在后排和里面的人聊天。后来我问她，“为什么要和我一起去玩？” “亲戚来了，心情不好。” 然后抓着我的手（囧） 后来可能是我买的VIP专座，司机让我换车，我不愿意和她分开，她在哪儿我就在哪儿。心里默默认定这是我女盆友了。到站了，场景在一个很奇怪的酒店。一脸尴尬的解释说我们不住宿，拉着她匆匆离开。后来，她和姐姐不知道去找什么东西了。 随后又在路边听到声音，可是怎么也找不到人。 想发微信，可是怎么也找不到她了。想到那天买票加好友都跟我发了好多消息。哭。梦中醒来，我喜欢萌萌的短发小姑娘。19.3.7 茫茫人海中，我的那个她上辈子是这么走散的吗？直至今日我还没找到她？突然发觉一段淡淡的音乐，一封短短的信，才是容易激起心潮澎湃波浪。 19.4.22平淡与长情： 纯粹喜爱来自好奇心的热忱，因为难才好玩。幸运的是凭借这份喜爱，还能混一口饭。19.4.22 写了一行就烂尾也是服了自己。我想和你谈谈生活，梦想。正好放到张国荣的往事，自从看了《霸王别姬》后就发觉深情的男人那么有魅力，所以我要努力，毕竟我是那么的绝情，连陪伴都没做到，一个人天南地北的乱跑。我想我们这一代很难提梦想。生活变化的太快，物欲横流。我们要不仅接受父母辈传达的希冀，切断增熵的幻想。混乱的经济，不得不向生活低头。可能我的脑子里太多悲观的因素，甚至喜爱伟大的悲剧。看到你的生活，心想这个姑娘坚强的让人心疼。 19.4.23 烂尾，强拧的瓜不甜我就是我不一样的烟火。不再放下姿态，用才华支起尊严。 4.30生活总是被琐事绊住脚步，不愿让别人看见自己不光彩的样子，总是戴着面具。 5.5很多时候，日常琐事会像一记耳光一样把人唤醒，让那些胡思乱想变得无关紧要，甚至有些可笑。 5.17《失踪的孩子》想跟你讲一件悲伤的事情，我再也学不好数学了。每次看到一些应用涉及到数学原理的时候总会望而却步，今天鼓起勇气，翻起傅里叶变化，心中还窃喜到达人生巅峰，看了一堆介绍和视频讲解后就困得昏睡过去，脑壳生疼的醒过来，内心又是一片绝望。 5.18梦见坐在婷婷的车上，一辆红色的跑车。疯狂的往另外一辆车上撞，最后成功的翻车了。 奇怪的是分身出第三个人，她的助理。5.20原来自己很在意，早干嘛去了？傻逼。 5.22得知一同学结婚的消息，心思有点凝重。到了夏天对生活的热情就减弱了，内心只剩下一点粗线条的渴望，凉爽。 5.25看到别人的幸福我会难过。 我不知道这些年我是干什么去了？我后悔了，我以为我不会的。我的表情有些麻木，我想跟你讲讲我的感情故事。高中我希望我的前桌，她过生日时我给她准备了礼物，最后没敢送出去。她是一个大大咧咧的姑娘，而我害怕被拒绝后就不再理我。后来我才明白她根本就是喜欢我的，而我不知道为什么一二再而三的把事情变糟。我以为她喜欢我，她以为我喜欢另外一个姑娘。日常生活就是她转过身来和我打情骂俏，乐此不疲却神经大条。有一次考试中她传了一条纸条，我是想把答案传给她，没等我穿就被发现了。她哭丧着脸求老师把试卷传给我，记忆中我挺高兴的，因为我俩一起做了一件事，虽然有点丢脸。想到我们俩的名字被一件事联系起来我也觉得很高兴呀。我痛恨文理分班，至少站在学术的角度来说，还是我自身对于分离的感觉来说。此后我似乎一直让她伤心，听她宿舍的同学说她很多次问了我的号码又删掉，哭了很多回。那时候我根本没有意识到自己真正的感情，我想我很滥，我会因为很多原因欣赏一个女孩子又不敢吐露心思，我始终不能把握身边的人。想不到短短几年时间我竟然把过去的种种全部忘记了，我想回去那个时候重来一次。我讨厌那时候自己的样子，我很恨自己。2018.5.27没有什么事比专注一小时更加畅快的了，今天用合适的姿势获得了很多年已经丢失的那种平静和满足，这种感觉是意犹未尽的。工作多年之后发觉学习是多么一件幸福的事。 6.23洗澡之后是在钟书阁闲逛发现的一本小书，之前听说过洗澡的大名，但不知道内容讲的是什么。这个题材挺好的，对人物的性格刻画也很丰满，只是感觉和钱钟书的围城比较起来还是差点意思。毕竟叙述的风格也大有不同。为自己喜爱的小说补上结局，很可爱的行为，盖棺定论。 读完我不喜欢这个结尾，因为太圆满了，故事也略显仓促。 没有达到君子之交的效果，让我有些失望。2017.7.22我不信轮回转生，谁不是第一次做人？生而为人我很抱歉。 从孩提时代起，我就是一直在讨好周围的人，这是我对人类最后的求爱。可我这一生尽是可耻的事。因为怯懦，所以逃避生命，以不抵抗在最黑暗的沉沦中生出骄傲，因为骄傲，所以不选择生，所以拒绝粗鄙的乐观主义。 人间不值得。 7.23 人间失格 粗制滥造阅读的乐趣在于思考，而不是阅读本身。 7.25]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收录年少的我 2016-2017]]></title>
    <url>%2Fdiary%2Fm2016.html</url>
    <content type="text"><![CDATA[续2015. 继续回溯16-17，17年的记忆被拦腰截断，再也寻不回了。不该对生活，对人生失去耐心。前天晚上想的情绪高涨的事，第二天很快就被打败了。其实吧，我根本没有去争取，没有去坚持，只是内心在作怪罢了。 很俗套的话，又是新的一年，我不能和前几年那样浑浑噩噩了。 我一点都喜欢现在的我，连自己的事都不太在乎了。偶尔会被在乎的人伤到，那感觉真是。 突然觉得沉默久了，真的就沉默了。洗个澡，重新来过吧。 静静静，写下人生目标。 –16 1.1 新年伊始,就丧了。王小波说：“人在年轻时候，最头疼的一件事就是决定自己这一生要做什么。”我们都一样，年轻又迷茫，未来遥遥无期，生活没有方向。既然不知如何是好，不如多做点实事，多走走斜坡石阶，也趟趟浅溪小河，尝尝煎饼果子也吃点麻辣火锅，别人彷徨的时间你把每一天过扎实，日复一日回头看，迷茫的人还依旧在迷茫，而曾经的你一定会喜欢现在的自己。 –16 1.7 不出意外是引用吧。“我是一个男人，有着男性的恶劣品性：粗俗、野蛮、重物轻人。其中最可恨的一点就是：无缘无故地想要统治别人。” –16 1.12 着了小波的魔是不是幸福的感觉来得太突然，任性就任性了。–16 1.我觉得不可思议某人的变化有点大。是不是被我感化了。如此说来我还是很有魅力的，哈哈哈 –16 2.19刚过完年写上班的状态就像打酱油，每天玩到半夜，堕落成这个样子。说好了，今年要做的事那么难，自己却一点没往正轨上移动。–16 3.2 后面列了一些计划凡是坚持的一概没做到。我还在做我的第一份工作。我发现我很容易受一个人的波动很大，可能我是我变得足够的冷淡，以至于对唯一在乎的几件事变得特别敏感。–16 3.6我有满腔愤怒，我如何待你，你又如何待我。可能我对你要求太高吧。你这样的人，真的不知道什么是落难。人说滴水之恩当涌泉相报。我是有漂泊的经历，也被伤过。却不想这记巴掌如此响亮。事与愿违，我也便无话可说。难养也，可能便是我的心境吧。我只不过想与人交善罢了。既然如此，那便路人耳。 –16 3.15对曾经荒废的时光致意，对不起。现在还有机会重新开始，毕竟我还年轻。 –16 3.25上个星期的期许就到了今天，我又荒废那么些天。始终处于堕落的边缘，偶尔就抱怨一声时不待我。我想做一件事，真正能坚持下去的事，而不是三天打鱼两天晒网。其实人只要对自己狠一点，比如我决心三个月没啃下2440，那么自然每天去做便可以了。 –16 3.29坚持了半个月的样子，最后一句话 。 晕三月已经疯狂的过去，四月把握好自己。 –16 4.1我不懂极猎者的回报是什么，更不明白那群人为什么跟着他？仅仅是一种信仰。从始至终他们提到的是美？–16 4.1《极盗者》很精彩，内心的呐喊，为了好玩。可能我这人太爱慕虚荣，被人夸两句就上天了。 –16 4.2实际是缺乏被认可吧。美妙的人生关键在于你能迷上什么。 –16 4.10梦见大庭广众之下强吻一个姑娘，真的好美。 –16 4.21我老爱做这种梦，叫做哪个少女不怀春？我发现我在回忆中，我特别特别害怕，失控。 看到结婚，我特别难过。 –17 10.28谁结婚了让我心情起波澜了？创造者和拥有者对他们所创造和拥有的物体没有认同感。 –17 11.29中年人的办公方式倾向于养生平静，我却爱闹腾，翻江倒海。我恨透了波澜不惊，感觉老之将至。 –17 11.30我的回忆在16年断了琴弦，是不是换手机了。我倒觉得我们是教育部不断试水的一代。 –17 12.1 哪一代都是吧，这叫局部放大原理。作为开发者大抵都是又开源精神的，莫不过本身接受了太多开源社区的帮助。–17 12.1笑里藏刀已经成为常态，为了表达我内心的诚挚，我决定应该坦诚相待。可是这个强盗年代将相濡以沫定义为耍流氓。–17 12.1在字里行间，你隐约可以心这样的意味：”这是机器，它和周围环境中的一切都没有关系，和你也没有关系，你和它也没有关系；你只需要懂得操纵某些开关.维持电压的强度，检查某些毛病等等。”就这么一回事。修理人员维修这些机器的态度就和这些手册所透露出来的态度是一样的，都是保持旁观者的立场。人们认为关心自己所做的事一点不重要，要么就视之为理所当然。在帮助同事解决编完程问题后，我却深受打击。他丝毫不关心到底是什么造成此次危机，只是觉得这样大笔一挥，于是乎就万事大吉了。–17 12.1突然觉得在这个异乎寻常浮躁的年代，保持一颗初心是多么有重要的事，而现在就连一个人静静发个呆都那么难了。 –17 12.1当你没日没夜为解决一个问题耗费所有精力时。你不难想象，作为这个状态下人，哪还有时间顾及其他一切无关痛痒的事情。 –17 12.1笑里藏刀已成为常态，为了表达我内心的诚挚，我觉得应该坦诚相待。可是这个强盗年代将相濡以沫定义为耍流氓。–17 12.1禅与摩托车维修艺术笔记科技基本形式古典的认知 浪漫的认知古典，认为这个世界由一些基本形式组成浪漫 是从它的表像来观察所有的一切都必须经过测量和证明，这就给人一种压迫感，一种永无止尽的灰暗，这就是一股死亡的势力。对浪漫的人来说，这种古典的方式显得沉闷，呆滞而丑陋。对一个古典的人来说，浪漫的人显得轻浮而没有理性，心情起伏不定，不值得信任，只对享乐感兴趣，是一种肤浅的人，像寄生虫一没有内涵，无法养活自己，是社会的负担。–17 12.1 《禅与摩托车维修艺术》读书笔记想了想我们国家的历史，觉得说我们国家的历史好像有点奇怪。这些历史更像是民族的历史。不过呢说中华56个民族实在有些过分，或许有些本身民族并不认可。这个呢，想法比较弱，得查查历史。 –17 12.5午觉中半梦半想未来，以及城市。少了缺乏初来乍到的勇气。偌大的城市，只是偏居一隅。想到西湖，想到苏堤东坡路， 四万八千烦恼风如洪水猛兽嘶鸣而来，思定，应作如是观。–17 12.6关于认识昨天和别人提到 奥巴马握手20万的话题。第一反应，弱智？炒作？于是乎没有兴趣的回了一句的想能提出这个话题的人决定也属于无脑组织。最后被怼了一句，你认识奥巴马吗？当然我说不认识。然后就被鄙视了。接着，来谈谈认识。认识应该是认和识。我只认得，当然不能说认识。所以我也懒得与这位仁兄交流。在我们这个年代，认应该没多少人有疑问的吧。识呢？我们看到的不过是媒体给我们灌输的一个人，他有什么性格，做了什么事？捏造的？真实的？ 所以只在这个前提下谈识，也不免太肤浅。–17 12.7假如文明人的追求并不比野蛮人高尚，假如他把生命的大部分都只用于谋取基本的必需品和舒适品，那么他为什么要比野蛮人住得更好呢？最好的艺术作品应该表现人如何奋斗着将自己从这种境况中解放出来，但我们的艺术却只致力于使这种低级的境界变得舒适，并让人忘记更高级的境界。 –17 12.10 瓦尔登湖化身为挥舞着红袍的斗牛士，不是普罗米修斯的教义，只是享受妙曼的舞姿。 –17 12.13 遣词造句，感觉这一刻我是个小丑，连自己都没有逗笑。看电路原理有感佛学属于哲学范畴。哲学是自然科学(宇宙万物的真理)，自然科学是现代各种科学的集合(如计算机科学，更具体衍生的应用是软件工程)，所以自然科学应该是抽象出来的共性。所以呢，所以我们可以用禅开解释各种科目，只不过是共性的具体化。所以佛性就好理解了。那学佛不应该仅学佛，缘木求鱼，而是应该在生活学习中去体会。最后一点，面相对象编程的概念，不就是生活的哲学吗？ –17 12.13我想呢，最好的感情是一起成长。我对你知根知底，我走了崎路，你会把我打醒。你摔倒了，我会扶你一把。 –17 12.20用脸阻挡狂风，微笑还以颜色。早安。–17 12.21 那天我是个诗人。关于良质。对于事物的定义应该是谨慎的，当无法全面认识到本质，定义也就阻碍自己与他人的理解。所以我无法定义它，于是我开始窥探。对于自己，自诩甚高，却不想早已深陷泥潭。当创作沦为复制粘贴，于是乎极易跌入泥潭，在盲错后才略显惊愕。这也就是良质丧失原因，僵硬麻木如同奔丧。昨天我用两分钟解决了一个问题，与其说解决，但不不如说是抖了机灵绕过去了。昨晚就一直有一股悬在心上的感觉，感觉随时就会像病毒般失控。早上我找了个机会，找到了问题的所在。这个小小的问题如梦魇一般纠缠着我，或许产生这种不适是由所谓的良质。 –17 12.22被文字撩到时什么感觉，就像一把尖刀直插心脏。–17 12.27为啥我发的故事没有图？好好好，那我告诉你，我那么善良，一定是在给你省流量。 呸呸呸，正经的说： 那是因为我善良的笃信， 一句温情的文字胜过千军万马。 不过还是败在浮夸的表情包下。–17 12.29]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收录年少的我 2018]]></title>
    <url>%2Fdiary%2Fm2018.html</url>
    <content type="text"><![CDATA[续2016-2017，18年记录的事很少，对于生活的麻木，多半是零碎不堪的字迹。什么灵丹妙药，不过一计泻药。 18.1.7 记我对喝中药的不屑。儿时会幻想自己坐在龙椅上，作威作福。想来多半是古装剧的荼毒，近读万一十五年，才知君王不过时代的傀儡罢了。逆而行之，自取灭亡罢了。18.1.8 《万历十五年》思梦梦。长吻，长情。边走边吻，羞煞路人。从脸庞滑至嘴唇，温润而美好。你的眼睛真美。哈？怎么美？双眼皮，大大的眼睛，眼神一触，嘴唇便缠绵了。18.1.8 怪诗，又怀春。日常小记梦想总有三头六臂，花在纸上的张牙舞爪顷刻只剩断壁残垣。 18.1.9我们所能知道的关于物理空间的一切，就像一个天生的瞎子之能够通过别人而知道的关于视觉空间的一切。但是，一个天生的瞎子有他对于视觉空间所永远不能知道的事情，我们对于物理空间也有不能知道。多么精妙绝伦的比喻，我们不正像瞎子一般不断的猜测和试探世间法。18.1.12内心空洞乏味，只是因为不再被感动。 2018.9.23芸芸众生在绝望中过活，所谓乐天知命是一种根深蒂固的绝望。绝望弥漫于城市，遍及于乡村，我们只好身着麝皮和貂皮的华丽服装以求安慰自己。即便在人类谓之游戏和娱乐的行为背后也潜藏着那一成不变隐匿难察的绝望，压根儿就没有什么纯粹的游戏，因为那是对操劳的一种补偿。当然了，不染指于绝望的事情，也算是智慧的一种表现。 2018.10.15想象与实在哲学企图回答根本问题，既直接可靠的知识，宇宙万物的本质？哲学先探讨这类问题令人感到困惑的所在，并认识潜伏于我们日常观念中的种种模糊与混乱，然后才批判地做出解答。“现象”与“实在”的区别，事物好像是什么和究竟是什么这两者之间的区别。现象:人通过视觉、触觉和听觉获取到关于颜色，质地，形状，味道，气味，声音，硬度等，这类可以直接认识到的东西，称之为感官材料。实在:我们认为真实存在的东西 称为物理客体。所有物理客体的总和称为物质。我们需要研究物理客体与感官材料的关系。透过现象与实在，我们抽象的表述为两个问题:1.有没有物质这种东西？2.如果有，物质的特性是什么？萧红幸福千篇一律，而悲惨千姿百态。所以伟大的作品只能是悲剧。而悲剧就是将幸福在眼前毁灭。很小的时候，或许关于男女之情是从游戏得来的。一场悲情的宿命最终被连绵的荒垠吞噬。从此我便爱上了悲剧。两部电影讲萧红。我偏爱黄金时代，正因为埋藏在血液里的歇斯底里才使人沉重。2018.1.28时光匆忙的城市，手忙脚乱的前进，于蝼蚁无异，为活而活。 又想到瓦尔登湖，果见现代人的生活又比原始人好到哪里去呢？拉的长长的时光，才觉得弥足珍贵。 2018.2.4围城的失落正如 城外的人想进来，城里的人想出去这般。本就是些零散的小事，竟折腾的那般疲倦。而事两端的主角却各自窝火，想来谁不是心高气傲，又怕坏事。可偏偏越担心就越发生，真叫人好不生痛快，惨的像汤锅里的螃蟹。不知不觉熟了，手里的大钳子空无力气去使唤。可我心里却是进城人的心态，全然不把这劝告当做一会儿事，小事一桩罢了。2018.2.5入戏今天发现了一个想象就是观看影视作品入戏太深的问题(O_O)？ 这一个想象叫做共情,直接表现是感情泛滥。极度讨厌贴标签的行为，为何生儿为人却被这种无聊的词说限定。 算了对于无知且无畏的人也懒得甩回去。 我多次想，在科技不断发现的现代，人类的思想和贫瘠程度，和山顶洞人处于同一水平。这是如何可怕的触目惊心。就拿甚嚣尘上的思维模式一词来说。啊？什么是思维？什么是模式？连如何思考都没闹明白，却要扣上这顶高帽子。2018.2.6发现停止成长的点发现一个有趣的点，去发现自己停止成长的点，如最近有没有做出令人敬佩的事？判断是否走近卓越或是平庸。2018.8.5动因理论于我们大多数人来说，最容易犯的错误就是，把重点放在努力获得职业成功的有形陷阱里。拿更高的薪水、得到更有声望的头衔、有环境更好的办公室，这些都是朋友和家人能够看得见的标志，标志我们职业上“成功了”。但是一旦你发现自己关注的是工作中的有形部分，你就是在冒险了，像我的同学那样，追逐海市蜃楼。如果你把下一次加薪变成最终让你快乐的原因，那么这就是一种无望的追逐了。我们应该时刻铭记在心：超过一定的临界点时，改善基础因素，如钱、地位、薪水、安全保障、工作条件、公司政策等都只是幸福的副产品，而不是产生幸福的原因。#动因理论 #基础因素 #动力2018.9.10梦游千岛湖记忆中千岛湖是水墨画，曾几次前往都未曾一探究竟。恰逢雨将我们引了过来。我想烟雨朦胧中湖光山色，才是最美的样子。起初，暴雨后的岛上烟雾缭绕，有种巡山小妖的感觉。站在游轮上，迎面吹来夹杂雨珠的风，周围的孤岛。2018.9.13 没有写完断了，经历了千岛湖水光潋滟和一日之间气象万千的奇况孤独很沮丧的事是再也写不出让自己满意的文字，又因为和自己独处的时间也消失殆尽。老友记的结束让我这铁石心肠也不免被搅的波涛汹涌。我意识到我从没有过挚友，甚至从来没有愿意接受一个人到这种程度，想来独来独往的人心里捂得严严实实的。或许还是有一两个谈的来朋友，不过年久失修，会担心婚宴朋友那一栏有些尴尬。可能是因为成长的环境让我有这样的性格，信任缺失。自卑又自负。满足性人格。今天给了自己独处的时间，离开家的这些年自己竟是这样的逞强。不愿意承认的便挖个坑填起来2018.9.17我的七年很想停住脚步让思绪飞一飞。本想定为我的十年，可十年太长倒退回去的年岁太过青涩。还是看看年长三岁的我吧。可能从那时候开始才算真正的我。什么都是光鲜动人，用一个动词形容就是想要追。那一年我想。。我想要拥有眼前的一切，而我万事不移，什么都吹不了我。从家出走应该是在这个环境下做出的最正确的选择，或许是我与齐鲁大地的缘分。可我后来才发现她不是我的真爱，我叛逃而归，投入西子湖的温柔乡中。 还能翻出即将离别的写下的一首小诗，作为我的新开始。今天回想起来，em…过程还算不错，挨个几处重锤。昨天很想吧。自己的想法，记住。哦，可是想的太多，找到找出可以记录下的东西的时候已经想不出任何东西了。嗯，嫌岁数总是非常好的文字。可以经过仔细的雕琢之后可能。连只言片语都剩不下了想把这些之前片语。挺题为我的十年。年之前是一个懵懂的少年，所以七年比较合适。我发觉不应该变成回忆录形式，这样未免太伤元气，而且。我发觉不应该变成回忆录形式，这样未免太伤元气，而且。而且事情的发展也不耽误，用时间为线索。今天是某一个节气已经记不起到底是哪一个节气了，只能记得快要到立冬了没想到在这么暖和的日子却是冬天了。这些都没想过冬天也有不错的收获。小波在黄金时代中写道，什么东西都吃不了我，可到了而立之年才发现这都是荒唐的想法。这些年的感受莫过于此。哥哥在一小哥哥哥在一直在装中写道。一追在追，那么可笑。但我对这个世界的看法。整天发型并不是一个褒义词，开始。什么事不能做，什么是对的。但是都没有过。我想要什么？我们被很可怕的一种标准的道德观给束缚住了。作为学生就应该好好学习，作为。工人就应该好好工作，作为老师就应该更好和教书。那作为原我应该干什么呢？我想问。走的时候我们就很像活在1984那样。2018.10.23写在2018年的结尾。每到一年的开始，或者是一年的结束为会涌现一大堆想法，但最后却留下的很少。总是在抱怨时间太少。可自己却木然度过。想起有人说过一句非常好的话。把时间花在刀刃上。我与身边的琐事。每每建立一种兴趣之后。总想把事情做到尽善尽美，可大多数都是。做不到完美，然后一直迟迟无法动手。最后落的兴趣全无。我想。我是一个急性子。做什么事情做什么事情都有一个呆的烂。当我的内心达到顶点时便会不了了之，可能最后的纠缠也就成了。最后的倔犟。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收录年少的我 2015]]></title>
    <url>%2Fdiary%2Fm2015.html</url>
    <content type="text"><![CDATA[看完《最好的我們》有感，任青春匆匆溜走，才發覺那份青澀的青春才是最好的我們。 誰的青春裏沒有那個姑娘呢？回忆很难再追忆了，我想用文字把回忆停驻于此。不经意之间发现自己过去的天地，给未来的你，也给未来的我。出乎世俗想象的是，科学其实远比任何娘们儿都风骚，玩科学比玩女人爽得多，得到一个成果所获得的高潮强烈而持久，不仅有快感，更有巨大的自我认同感，远胜于那几秒寒颤之后无边的空虚与落寞。所以陈景润其实是沉溺于美色不能自拔，身体弱架不住高潮过度被爽死了。–摘录 合我心境，我玩得是计算机科学，别问我计算机也能称得上科学？什么是梦想？很可悲，生活一片愕然。再也找不到那么一个人，促膝长谈，说不完的话题就是没有共同的。 –15 4.21生活待我很伤心。我这般真心… –15 5.17我发现我正在丧失感觉。这是一种精神疾病。 –15 5.21每个人都应该有一个梦想，否则会产生一种轻轻浮感，以至于失去存在感。最好的办法是，寻找一个自己感兴趣的事物，持续记录，说不定无心问柳。 2015 5.21突然想到一套年轻时候的理论，如果一本正经的讲出来，并带着一股强势语气，是何等气场。–2015.5.22深圳的一周，工作睡觉，充其量我只是占了一个位置打坐。天气已经热得让我无法适应，脑袋一片浆糊。期间，妈妈给我打电话说要给我介绍姑娘，我一时间无法适应，忙问怎么回事？我想我应该回家一趟，心累了。 我怀疑我是有多重人格的生物，从高中一段被拒的经历后另外一种人格就占据了主动。这个人格很烂，很马虎，做人比较麻木。我还是更喜欢哪个神经大条的我，自己的事情可以操八个人的心的神经病。其实，我发现我还是希望有家的感觉。现在还没太有这种感觉，现在催生了逃离回家的念头。 –15 5.30想不久可能就得相亲了，其实这件事我并不反对。最怕是见到喜欢的人冷场。有人说关键不是说什么，而是保持不无聊。em…就是说 “扯”，而且不被察觉，接下去。 –15 5.31走到浙大门口(紫金港)，发现心里萌生了要留下来的感觉。当前就应该为了这座城，所以我要做个决定。–15.6.1 所以这个决定失效了？梦见住在酒店，没看清对方的脸。二重梦醒了，剧情跳到第二晚，这次我又看见她那张没脸的脸，不知道她是为什么爱上我的？最后被回忆吻醒了。 –15 6.10梦见自己在唱《学不会》,我这样五音不全的人都能哼唱出天籁（旋律似乎不是来自这个星球，太好听了）。记忆中只有一句词是学不会，其他都是自我创作的。 -19 7.27 即兴回忆突然感觉之前的冰人不见了。 –15 6.13不知道是不是指自己,恐怕不是。脱口而接，冰释前嫌。广州，广州，三年前，当时还太嫩。–15 6.22记忆中当时在小蛮腰下发了一条信息：故地重游。 “我在想你”突然想起 野心勃勃 这个词。 就觉得得奉劝自己一句，再不拿出来就老了。 —15 7.12如何能找回当年的暧昧？ –15 7.14不知多年之后再回首这句话时，是什么呢？被”你”调侃吗？我特意加了””,因为我此时根本没有这句话的语境，所以当然是屏幕前的你了,或许只能是我了。孤独症患者七月,工作一年了。离家飘荡的这一年多，又有多少想法是一致的呢？有时候，人就像幽灵一般，萌生了想法就拼命去追，直到头破血流。这才是青春。 –15 7.14我把追到头破血流改为直到头破血流，感觉内心都热了，这个句子很喜欢。青春艳阳高照，我却躲在树阴下，以路人的心态看人间沧桑。时不时的探出脑袋。–15 8.5突然发觉生活好妥协，既没有大把大把的钱，为何这般疯狂的努力。 –15 8.20所有的故事都让我认清一点，自己的无能。路过还有机会我会再大胆一回。 -15 9.5伤到莫名处，我没有遵守我的承诺，我又一次缩回去了。 -15 9.6想起南京苏打绿演唱会的窘境。我一直在拖延，以至于一事无成。我心里都是她，却假装镇静。 –15 9.7成长过于迟缓，以至于总是羡慕同龄人有什么。 当急于证明自己可以独挡一面的时，便将自己粉饰的雍容华贵，失去了初心。年轻的心显得叛逆，流浪后才发现是孤独。–15 9.18于是乎，我决定做一个暖心的人。因为我很丑，但是我很温柔。 –15 9.18不管剧情千回百转,我只想让你们看清自己和世界。 –15 9.24宁静致远。我想要我以后的家，有一个大大的书房，上面大大的匾上写上这四个大字。 –15 9.26年轻的我嗜好这么优雅,5年了还没实现，因为我未曾前进，金元时代让人几近崩溃。她会关心这个问题，起码说明了一个问题，不会是没有任何感觉。我发现当我内心膨胀到一种程度，被拒绝后，真的是会被打回原形。 –15 10.7都说文人爱以一怀愁绪表达自己忧愁。而我目前正值这个时候，二十好几，一无所有，摸滚带爬，心里怀揣什么狗屁的梦想，实则想入非非而已。是生来彷徨，还是与地球共振的频率。对于拥有的东西都想流沙一般。所以，只求天长地久。可是，时间并不那么靠谱,–15 10.16逛到蓬莱仙境，然后便一起了。梦中的爱情总让人神往。 –15 10.16不要问我她是谁了？就连做梦都不能让我有片刻喘息吗？ 梦里的蓬莱是仙境,下一次我们去可好？看到的话,答应我。对于人生，我有些疲态。那些心心念念的感觉都不复存在了。一点没有憧憬， –15 12.24]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDNS 初探]]></title>
    <url>%2Fdraf%2Fddns.html</url>
    <content type="text"><![CDATA[说到搭建服务器这个话题总是绕不过域名和IP地址这个话题。如果我们能够申请到一个静态的IP地址，那么将域名和IP地址绑定就没有那么多事了。可理想是美好的，现实是骨干的,家庭宽带不大可能会分配给你一个静态IP。(IPv4的黑历史)两种情况：局域网地址动态公网IP地址怎么看自己家的宽带地址是公网地址还是局域网地址？1. WAN口插了网线。登陆到路由器里看看PPPOE拨号分配的IP地址是长啥样的？ = =. 10.x.x.x 那有点悲催了，万恶的局域网。 2. WAN口没有插网线，看下静态/或者动态IP地址。然后登陆到网关（猫）上去看看。 确认了IP地址之后：如果是动态的公网地址的话，那么且就接着看，下面介绍一种DDNS的东西。如果是局域网的地址，只能尝试内网穿透，有一堆限制条件，当然没有实操就不敢大放厥词了。好了，下面就开始以搭建一个FTP服务的目标讲这个心路历程吧。列一下网络的情况：100M光纤入户，光猫型号 TEWA-700G, 这个光猫还有路由器功能。当然我的是公网的动态IP了。1. 破解 TEWA-700G为啥要破解这玩意儿？因为实践证明这货不支持 思科的术语：NAT hairpin 华为的术语 NAT LoopBack.悄咪咪的一说，没文化真可怕，这个是网络中很基础的一个东西，因为TEWA-700G 不支持，我错误的判断成路由器不支持，走了很多歪路。那么不支持这个有什么实际的影响呢？在同一个局域网中的机器 无法通过域名来访问目标机器。一种简单的结局办法：就是修改全局的HOST文件，将域名全部自动替换成对应IP地址，那么这个IP地址就得做成静态IP。现在很多路由器中有设置HOST的功能，相对较方便一点。 如果不支持，只能修改系统的HOST文件，比较麻烦。麻烦的办法：不支持就换支持的咯。这里的思路就是关闭光猫的路由功能，改成桥接。相当于它成了一个网线口了。没办法高手在民间，这种烂大街的光猫早就被人破解过无数次了。哈哈哈 - s -2.动手破解这个光猫有好几个功能1.上网2.电话3.IPTV所以就不要乱碰其他的东西，免得惹出不必要的麻烦，记得拍照备份。首先，看光猫的背面贴纸，写了登陆的地址和密码。默认的地址是给一般用户的用的，另外预留了一个8080端口，才是真正有用的地方。先用贴纸上提供的的账号密码登陆 192.168.1.1:8080 这个页面。然后直接在浏览器页面上输入地址：192.168.1.1:8080/dumpmdmd.conf这时候会弹出一个文件下载。下载后,搜索TeleComAccount。实际是有这么一个页面查看路由器的账号和密码的都是明文展示的。囧，这样的漏洞。然后再这个账号密码来登陆。点击”网络”,在”网络设置”中选择连接名称中含有”INTERNET”的wan连接,将”连接模式”由”路由”改为”桥接”,然后点击”保存/应用”。要是想不起来PPPOE的账号和密码先不要着急改，账号和密码这里都有写。只是密码都是* 号，这里用到HTML的知识咯，F12打开浏览器的调试模式，慢慢找到密码的框，应该是什么passwd,改成text密码就暴露了。路由器端口映射这里路由器的PPPOE上网设置就不再啰嗦了。然后想这么一个问题，我们平时访问浏览器是用80端口，ftp 21端口。 这里很遗憾的是，电信服务商封掉了80端口。所以我们的http服务只能换端口。因为外网访问局域网内的一台机器，有那么多机器究竟该访问哪一台，这个就轮到端口映射咯。比如：我的公网地址是 183.122.147.53那么我希望访问 183.122.147.53:10021端口时，实际访问的是 192.168.1.101:21这个配置不同路由器界面不大一样 不过肯定都是配置 外部端口，内部主机地址，内部端口，协议类型，（选tcp和udp）就ok了。测试端口映射是否成功安装FTP服务首先我们先安装一下ftp服务器，为啥用它，因为windows自带，方便演示。控制面板-程序-启用或关闭Window功能。勾选上“FTP服务”、“FTP扩展性”和“IIS管理控制台启动ftp服务器:打开IIS管理器，新建一个FTP站点。ftp的路径随便填一个，ip地址写自己的ip,关闭SSL.打开匿名登陆，允许所有用户访问。测试FTP是否可以访问先用本机ip地址试。再用外网ip试试。先配置一下路由器的端口映射，这里我把21端口映射到外网的10021端口然后还需要关闭windows防火墙，不然访问不进来。也可以用在线工具检测一下相应的端口是否开放来判断是否ok.http://coolaf.com/tool/port2.AliDDNS测试终于是重头戏了，当然你需要一个域名，这里用的是阿里云的域名，自然就用aliyun提供的DDNS。P.S 普通的域名很便宜，申请也很简单，有了域名发现世界真奇妙，当然是对程序员来说的。哈哈哈哈，傲娇脸。阿里云提供 PYTHON和JAVA的SDK,其实都是通过发送HTML请求，写代码的事总归不适合测试，就用windows上的已经做好的程序测把。我找到了一个.net写好的程序：https://bbs.aliyun.com/read/289624.html先新建一个子域名用来测试：设置好accessKey,Seret,需要更新的域名，然后点击验证并保存。提示成功，我们去域名的控制台看了一下确实是更新过来了。接着再测试一把域名登陆ftp,同样是ok了。3.后记这篇文章写自用开发板搭建一个云服务器，呱。 有时间再说它把。码字比写代码累，这是真的。]]></content>
      <categories>
        <category>瞎捣鼓</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群晖设置 AliDDNS]]></title>
    <url>%2Fdraf%2Fqun_ddns.html</url>
    <content type="text"><![CDATA[最近看到蜗牛星际的矿机似乎挺火的花了270大洋购入了这台矿机。收到货的时候已经帮装上黑群晖 DSM 6.1.7-15284 Update 3 这个版本，也懒得自己再装一次了。配置是这样： J1900+千兆网卡+16G垃圾SSD+4G内存。忙活了一下午，也没能把闲置有坏道的硬盘修复过来，干脆直接仍上来算了。我是把原来9G配置的RAID1删除了，这么点空间没什么用处，然后把我这块硬盘挂上去，不选择做什么检查的，不然提示硬盘已经损毁。[我还在想怎么样后面怎么处理才能把我的坏块的文职绕过去呢,暂时先不管了。垃圾电源我也不太放心买块新硬盘，肉疼]二话不说先开启SSH和FTPS，登陆上来一看，原来大名鼎鼎的群晖也不过是一个Linux系统。admin@DS3617xs:/$ unameLinux这样的话感觉SO EASY，先设置一下root密码：passwrod 这个命令都没有，囧。sudo -isynouser –setpw root 密码然后看到硬盘挂载在/volume1下：/dev/md2 on /volume1 type btrfs (rw,relatime,synoacl,nospace_cache,metadata_ratio=50）再看看刚才随便装的套件视频、音乐。原来这些服务存放的地方就是这里。123456789101112drwxr-xr-x 1 root root 112 Apr 13 20:33 .drwxr-xr-x 23 root root 4096 Apr 13 17:36 ..drwxr-xr-x 1 root root 76 Apr 13 20:34 @appstoredrwxr-xr-x 1 admin users 58 Apr 13 20:31 @databasedrwxr-xr-x 1 DownloadStation DownloadStation 30 Apr 13 20:33 @downloaddrwxrwxrwx+ 1 root root 30 Apr 13 20:34 @eaDird---------+ 1 root root 12 Apr 13 20:34 musicd---------+ 1 root root 12 Apr 13 20:34 photodrwxr-xr-x 1 root root 24 Apr 13 20:31 @S2Sdrwxrwxrwt 1 root root 48 Apr 13 20:34 @tmpd---------+ 1 root root 12 Apr 13 20:33 video最好闲话扯一下这个应该是debine系统，可能不太完整，起码dpkg这个安装软件的方式还可以用。接下来说AliyunDDNS 发现早有人写好了脚本，那就顺手牵羊了。https://github.com/cuteribs/ribsnetwork/blob/master/ddns/aliyun.sh这里我存到/volume1/script/ddns/aliyun.sh 下,为了以后调试方便起见建立个log文件夹以后将ddns的信息存下来。脚本执行4 个参数 AccessKeyId AccessKeySecret 一级域名 二级域名。 测试之前我先增加一个二级域名。123456789101112cd /volumn1mkdir -p script/ddns logcd script/ddnswget https://raw.githubusercontent.com/cuteribs/ribsnetwork/master/ddns/aliyun.shchmod +x aliyun.sh root@DS3617xs:/volume1/script/ddns# /volume1/script/ddns/aliyun.sh acc_id acc_pass domain qun获取当前 IP...当前 IP 为 125.x.x.x.获取 qun.lilonghua.top 的 IP...域名记录已存在, 更新 qun.xxx.top 至 125.x.x.x...qun.lilonghua.top 已指向 125.x.x.x.再看看一下是否生效：接着我们把这个脚本加入到群晖的定时计划中去。控制面板–高级模式-任务计划-新增多久执行一次我设置成10分钟吧，因为TTL是600s，刷新的再快也得10分钟。这里执行失败了可以邮件提示，这里脚本写的没有返回错误，所以就先不加了，后续可以完善一下。]]></content>
      <categories>
        <category>瞎捣鼓</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android C++智能指针]]></title>
    <url>%2Fandroid%2Ftools%2Fsmart_point.html</url>
    <content type="text"><![CDATA[在C++编程中我们常常会碰到这样一个问题，我们对动态分配的内存存在管理不当。1.忘记释放内存空间2.重复释放内存空间这两种问题分别对应的是内存泄漏和程序的崩溃。为了解决手工繁琐的释放内存空间的问题，Android引入了智能指针的概念，用以自动处理动态内存分配，防止人工处理的失误。我们首先复习一下典型的失误的代码：1234567891011//1.忘记释放造成内存泄漏int main()&#123; string * s =new string("Hello World!"); return 0;&#125;//1.重复释放内存空间,导致程序崩溃int main()&#123; string * s =new string("Hello World!"); delete s; delete s; return 0; 观察上述两个例子,结合自动释放内存空间的目标。首先我们观察到的是，我们是用一个局部变量来指向我们动态分配出来的String。如果局部变量在回收过程中能够帮助我们回收new出来的内存空间那么我们就可以高枕无忧了。 改造一下代码: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class sp&#123; public: sp():p(0)&#123;&#125; sp(string *s):p(s)&#123;&#125; ~sp()&#123; cout&lt;&lt;"~sp()"&lt;&lt;endl; if(p) delete p; &#125; private: string * p;&#125;; int main()&#123; sp p=new string("Hello World!"); return 0;&#125; 第一行的写法完全等价于下面的写法，也就是会调用参数是指针的构造函数去构造sp这个对象。sp p = sp(new String(“Hello World!”));当函数作用域结束后，编译器会帮助我们清理对象p的空间，也就是调用p对象析构函数，然后就delete了我们new出来内存的空间 。这样我们解决了第一个问题，我们便不会再忘记调用。 然后有人会说那这样估计我们也不会不小心delete两次了，哈哈，太天真了。我们看一下代码：这里我们加入了一个拷贝构造函数。运行一下：这里直接告诉了我们错误的原因：* Error in `./a.out’: double free or corruption (fasttop):因为p和p2对象会指向同一个string的地址，p和p1在调用析构函数的时候就出现了连续两次delete操作，造成了程序崩溃。12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class sp&#123;public: sp():p(0)&#123;&#125; sp(string *s):p(s)&#123;&#125; sp(const sp &amp;ss):p(ss.p)&#123;&#125; ~sp()&#123; cout&lt;&lt;"~sp()"&lt;&lt;endl; if(p) delete p; &#125;private: string * p;&#125;;int main()&#123; sp p=new string("Hello World!"); sp p2=p; return 0;&#125; 为了解决这个问题，我们想到应该在被引用的对象中加入引用计数，在sp调用delete之前判断一下当前被印用的次数，再相机行事。这里为了给string加入引入计数不得不创建了string的子类mstring。然后看到sp的构造函数创建对象时计数+1，释放对象时计数-1.当计数为0才释放对象。12345678910111213141516171819202122232425262728293031323334353637#include &lt;string&gt;using namespace std;class mstring :public string&#123;public : int incStrong()&#123;return ++m_count;&#125; int decStrong()&#123;return --m_count;&#125; mstring()&#123;&#125; mstring(const char *ss):string(ss)&#123;&#125;private: int m_count;&#125;;class sp&#123; public: sp():p(0)&#123;&#125; sp(mstring *s):p(s)&#123;p-&gt;incStrong();&#125; sp(const sp &amp;ss):p(ss.p)&#123;p-&gt;incStrong();&#125; ~sp()&#123; cout&lt;&lt;"~sp()"&lt;&lt;endl; if(0==p-&gt;decStrong())&#123; delete p; &#125; &#125; mstring* operator-&gt;() &#123; return p; &#125; private: mstring * p;&#125;;int main()&#123; sp p=new mstring("Hello World!"); sp p2=p; return 0;&#125; 这样就完成了我们非常简陋的智能指针，不过这个代码太过反繁琐，我们将计数剥离出来，以及将sp里存储的指针用泛型代替掉，使得程序更加通用。这样我以后写的类只用继承refBase类即可。指针类的代码也无需修改了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class refBase&#123;public: int incStrong()&#123;return ++m_count;&#125; int decStrong()&#123;return --m_count;&#125;private: int m_count;&#125;;class mstring :public refBase,string&#123;public : mstring()&#123;&#125; mstring(const char *ss):string(ss)&#123;&#125;&#125;;template &lt;typename T&gt;class sp&#123; public: sp():p(0)&#123;&#125; sp(T *s):p(s)&#123;p-&gt;incStrong();&#125; sp(const sp &amp;ss):p(ss.p)&#123;p-&gt;incStrong();&#125; ~sp()&#123; cout&lt;&lt;"~sp()"&lt;&lt;endl; if(0==p-&gt;decStrong())&#123; delete p; &#125; &#125; T* operator-&gt;() &#123; return p; &#125; private: T * p;&#125;;int main()&#123; sp &lt;mstring&gt; p=new mstring("Hello World!"); sp &lt;mstring&gt; p2=p; return 0;&#125;``` 这部分的实现和Android的轻量指针的核心部分的差不多，这里只是为了解决当前的问题而简化的代码。 轻量指针之解决了我们提出的两个问题，还存在两外的问题：无法解决相互引用的问题，这个问题后面再分析我们去Android代码再看看轻量指针的代码。``` c++ //frameworks/base/include/utils/RefBase.htemplate &lt;class T&gt; class LightRefBase &#123; public: inline LightRefBase() : mCount(0) &#123; &#125; inline void incStrong(const void* id) const &#123; android_atomic_inc(&amp;mCount); &#125; inline void decStrong(const void* id) const &#123; if (android_atomic_dec(&amp;mCount) == 1) &#123; delete static_cast&lt;const T*&gt;(this); &#125; &#125; //! DEBUGGING ONLY: Get current strong ref count. inline int32_t getStrongCount() const &#123; return mCount; &#125; protected: inline ~LightRefBase() &#123; &#125; private: mutable volatile int32_t mCount; &#125;; ``` 快速扫了一眼,就是比我们实现的稍微多了一个细节的处理，对mCount的操作都是原子操作，还有将delete的操作放到了这里进行，个人感觉没什么区别。再看看sp的实现,我们看一眼头文件，里面有一个weakref_type我们先忽略它，还有一些运算符重载。核心的就是构造和析构函数，看了一下实现和我们的没有多大区别：``` c++ //frameworks/base/include/utils/RefBase.htemplate &lt;typename T&gt; class sp &#123; public: typedef typename RefBase::weakref_type weakref_type; inline sp() : m_ptr(0) &#123; &#125; sp(T* other); sp(const sp&lt;T&gt;&amp; other); template&lt;typename U&gt; sp(U* other); template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other); ~sp(); sp&amp; operator = (T* other); sp&amp; operator = (const sp&lt;T&gt;&amp; other); template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other); template&lt;typename U&gt; sp&amp; operator = (U* other); //! Special optimization for use by ProcessState (and nobody else). void force_set(T* other); // Reset void clear(); // Accessors inline T&amp; operator* () const &#123; return *m_ptr; &#125; inline T* operator-&gt; () const &#123; return m_ptr; &#125; inline T* get() const &#123; return m_ptr; &#125; // Operators COMPARE(==) COMPARE(!=) COMPARE(&gt;) COMPARE(&lt;) COMPARE(&lt;=) COMPARE(&gt;=) private: template&lt;typename Y&gt; friend class sp; template&lt;typename Y&gt; friend class wp; // Optimization for wp::promote(). sp(T* p, weakref_type* refs); T* m_ptr; &#125;; //cpptemplate&lt;typename T&gt; sp&lt;T&gt;::sp(T* other) : m_ptr(other) &#123; if (other) other-&gt;incStrong(this); &#125; template&lt;typename T&gt; sp&lt;T&gt;::sp(const sp&lt;T&gt;&amp; other) : m_ptr(other.m_ptr) &#123; if (m_ptr) m_ptr-&gt;incStrong(this); &#125; template&lt;typename T&gt; sp&lt;T&gt;::~sp() &#123; if (m_ptr) m_ptr-&gt;decStrong(this); &#125; 回到我们刚才又提到的话题，我们的轻量指针不能够解决相互引用的问题？那么什么叫相互引用呢？比如说：123456789101112131415class A :public LightRefBase&#123;public : void set( sp&lt;A&gt; &amp;a)&#123;m=a;&#125;private : sp &lt;A&gt; m;&#125;int main()&#123; sp &lt;A&gt;a1 =new A(); sp &lt;A&gt;a2= new A(); a1-&gt;set(a2); a2-&gt;set(a1);&#125; 第三行会使得a2的引用计数变为2,下一行让a1的引用计数变为2.任何一方都无法调用delete，这样就导致了都不能释放。 为了解决相互引用的问题，引入了强弱指针的概念。这里的sp就是强引用计数，那么我们就不能再m这个数据成员能够增加强引用计数。改成弱引用计数，于是就不会影响到delete。 看起来就是一个没有用指针，没错就是这样。然后将弱指针设计成无法使用，必须转化成强指针才能使用，如果发现对象已经释放那么转化就失败，这样就解决了，万一对象已经释放又对指针进行了操作。 Android的强弱指针实现起来有点复杂，其中有一个flage标志这delete的时机。1.强引用 (根据强引用计数)2.弱引用 (根据弱引用计数)3.永远存在 (和C++普通指针没什么区别) 阅读源码发现，增加强引用的同时还会增加弱引用，所以弱引用总是大于等于强引用。所以弱引用必须要升级为强引用才能使用，防止弱引用对象已经释放。这里提供了3中机制，而实际使用基本上只会用到强引用计数决定delete的情况。 弱引用的实现有一点比较有趣的地方。 接口定义和实现是分离的这一点非常的有意思。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>Android</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Android</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1984]]></title>
    <url>%2Fbook%2F1984.html</url>
    <content type="text"><![CDATA[战争即和平,自由即奴役,无知即力量.与《1984》结缘于一年前，当时被肃穆的气氛击退了。显然这是一本需要凝神静气的书，走马观花无异于打肿脸充胖子。直到过年时的大片空白时光才有幸重拾。在肃穆的背景下,Julia写给Winston纸条上竟赫然印着三个大字：“我爱你。” 在震惊之余，世界崩塌了。－－我们还活着。原来世间仍有“黄金乡”，如蝼蚁般的我们依旧热忱,依旧可以一同大声呐喊“打到老大哥”。1984仅仅用了15个字，就创造了这个完美的自欺欺人的世界。战争即和平自由即奴役无知即力量我们生存的社会经历过无数的变迁依旧保持稳定的上中下三大阶层。然而政权的交替无外乎是：中等阶层用蛊惑下等阶层合力推翻上等阶层，最后下等阶级依旧是下等阶级，而上等阶级和中等阶级进行了重组形成了新的上等阶级。所以为了维系上等阶级的利益，保证政权用不会被推翻，用这１５个字便维系了政权的稳定，精妙绝伦。战争即和平：按以前的战争标准来看，现在的战争完全是假的。这好象是两头反当动物，头上的角所顶的角度都不会使对方受伤。但是，尽管战争不是真的，却不是没有意义的。它耗尽了剩余消费品，这就能够保持等级社会所需要的特殊心理气氛。下文就要说到，战争现在纯粹成了内政。过去各国的统治集团可能认识到共同利益，因此对战争的毁灭性虽然加以限制，但还是互相厮杀的，战胜国总是掠夺战败国。而在我们的时代里，他们互相根本不厮杀了。战争是由一国统治集团对自己的老百姓进行的，战争的目的不是征服别国领土或保卫本国领土，战争的目的是保持社会结构不受破坏。因此，“战争”一词已名不符实。如果说战争由于持续不断已不复存在，此话可能属实。人类在新石器时代到二十世纪初期之间受到的这种特殊压力，现在已经消失，而由一种完全不同的东西所取代。如果三个超级国家互相不打仗，而同意永远和平相处，互不侵犯对方的疆界，效果大概相同。因为在那样情况下，每一国家仍是一个自给自足的天地，永远不会受到外来危险的震动。因此真正永久的和平同永久的战争一样。自由即奴役：没有人会为了废除权力而夺取权力。权力不是手段是目的。建立专政不是为了保卫革命；反过来进行革命是为了建立专政。迫害的目的是迫害。拷打的目的是拷打。权力的目的是权力”“一个人在单独和自由的时候总是要被打败的，所以必然如此，因为人都必死，这是最大的失败。但是如果其能完全绝对服从，如果能摆脱个人存在，如果他能与党打成一片，那么他就是全能的，永远不朽……”力量即无知：在自己的思想中容忍矛盾，使思想者非有意说谎，但又真的相信这种谎言，相信党所告诉他的谎言是真实的，使之成为一种诚实的自我欺骗，从而达到控制者所希望的思想定向。实施这种思想控制的根据是，现实世界是存在于意识之中的，过去的历史和现在的世界都是存在于意识之中的，除了通过人的意识，什么都不存在，所以这个社会的一个核心党员坦率地承认，对物的权力并不重要，所谓权力乃是对人的权力，而尤其是对人的思想的权力，控制了思想和意识，就能控制客观世界。控制了人的记忆，就控制了过去；控制了人现在的思考、感觉和情感，就控制了人的现在；控制了人的欲望、希望和憧憬，也就控制了人的未来。而控制人的记忆、思考和希望这三者自然是相互联系的。写到这里我想起来了鹿鼎记中韦小宝和陈近南的对话,所谓冠冕堂皇的口号只不过是为了满足个人私欲罢了。陈近南意味深长地：“小宝，你是个聪明人，我可以用聪明的方法和你说话，外面的人就不行”。韦小宝茫然：“不解”。陈近南：“小宝，你知道，现在 聪明的人大多数已经在清廷里当官了，所以，如果我天地会要同清廷对抗，就只能用一些蠢人了。对于那些蠢人，绝对不可以对他们说真话，只能用宗教的形式来催眠他们，使他们觉得所做的事情都是对的……所以反清复明只不过是一句口号，跟阿弥陀佛其实是一样的”。韦小宝眨眨眼：噢。陈近南：清朝一直欺压我汉人，抢走我们的银两和女人,所以我们要反清……韦小宝打断陈的话：“要反清就是因为他们抢了我们的钱和女人，是不是？复不复明不过是脱了裤子放屁，关人鸟事呀！行了，大家都是聪明人，了解！继续说”。陈近南点头：“总之呀，如果能做成功的话，就有无数的银两跟女人，你愿不愿意去呀？”韦小宝大喜，激昂地道：“愿意！”所以说呢，口号是喊给外人看的，戏演的的是掩人耳目。在１９８４的世界里：”编纂历史,铲除异己,消灭思想,拥护老大哥。” 然而这种令人难以置信的政治寓言小说却真实的在我们的这片土地上实践过，深深的倒吸一口凉气。小说的尾声也即高潮：黄金乡逝去，再也没有什么可以值得怀疑的了。２＋２＝５．他现在不再跑了，也不再叫了。他又回到了友爱部，一切都已原谅，他的灵魂洁白如雪。他站在被告席上，什么都招认，什么人都咬。他走在白色瓷砖的走廊里，觉得像走在阳光中一样，后面跟着一个武装的警卫，等待已久的子弹穿进了他的脑袋。他抬头看着那张庞大的脸。他花了四十年的功夫才知道那黑色的大胡子后面的笑容是什么样的笑容。哦，残酷的、没有必要的误会！哦！背离慈爱胸怀的顽固不化的流亡者！他鼻梁两侧流下了带着酒气的泪。但是没有事，一切都很好，斗争已经结束了。他战胜了自己。他热爱老大哥。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>文章漫游</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>读书感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《围城》]]></title>
    <url>%2Fbook%2Fweicheng.html</url>
    <content type="text"><![CDATA[城中的人想出去，城外的人想冲进来.围城写的是男人和女人的故事。在这个世间总共有三类事：男人之间的事，女人之间的事，男人女人之间的事。我不知道女人之间的事儿是怎么样，男人之间的事儿却绝大多数事都和女人有关，所以男女之间事儿自然是有趣的。钱钟书先生在序中写道：”这本书整整写了两年。两年里忧世伤生，屡想中止。由于杨绛女士不断的督促，替我挡了许多事，省出时间来，得以锱铢积累地写完。照例这本书该献给她。”我想这段话写得足够明白，用妙语连珠调侃生活的空白，这对神仙眷侣真是羡煞路人。故事安排的足够精妙，大段大段的隐喻又是恰到好处。世间的事儿都足够的荒唐，而活在围城里的我们却只能束手就擒。用正常的男人眼光看待这本书的心理：平日的你总用痴字调侃我，这回我倒是要瞧瞧你的原型。下面的世间把把精妙的言论囤起来：她只穿绯霞色抹胸，海蓝色巾肉短裤，漏空白皮鞋里露出涂红的指甲。在热带热天，也话这是最合理的妆束，船上有一两个外国女人就这样打扮。可是苏小姐沉得鲍小姐赤身露体，伤害及中国国体。那些男学生看得心头起火。口角流水，背着鲍小姐说笑个不了。有人叫她“熟食铺子”（charcuterie），因为只有熟食店会把那许多颜色暖热的肉公开陈列；又有人叫她“真理”，因为据说“真理”是赤裸裸的”。鲍小姐并未一丝不挂，所以他们修正为“局部的真理”。可想而知现代的真理如此廉价，但总不能厚颜无耻的一窥究竟。借了要还的，一借一还，一本书可以做两次接触的借口，而且不着痕迹。这是男女恋爱必然的初步，一借书，问题可大了。现在才知道原来这种段子是从这里流传出来的，为啥我这里这么多书都没人来借呢？学国文的人出洋深造，听起来有些滑稽。事实上，惟有学中国文学的人非到外国留学不可。因为一切其他科目像数学、物理、哲学、心理、经济、法律等等都是从外国灌输进来的，早已洋气扑鼻；只有国文是国货土产，还需要外国招牌，方可维持地位，正好象中国官吏、商人在本国剥削来的钱要换外汇，才能保持国币的原来价值。有句话是老婆总归还是自己的好，人家的只能看不能碰😝文人最喜欢有人死，可以有题目做哀悼的文章。棺材店和殡仪馆只做新死人的生意，文人会向一年、几年、几十年、甚至几百年的陈死人身上生发。”周年逝世纪念”和”三百年祭”，一样的好题目。死掉太太—-或者死掉丈夫，因为有女作家–这题目尤其好；旁人尽管有文才，太太或丈夫只是你的，这是注册专利的题目。怪不得我一写起文章就觉得发闷，写完后总觉得的有抄袭之嫌，原来是文章题目非我独有，所以故如此。辛楣道：“像咱们这种旅行，最试验得出一个人的品性。旅行是最劳顿，最麻烦，叫人本相毕现的时候。经过长期苦旅行而彼此不讨厌的人，才可以结交作朋友——且慢，你听我说——结婚以后的蜜月旅行是次序颠倒的，庆该先同旅行一个月，一个月舟车仆仆以后，双方还没有彼此看破，彼此厌恶，还没有吵嘴翻脸，还要维持原来的婚约，这种夫妇保证不会离婚。”听完如雷贯耳，想着顺序颠倒后的后果自负，所以才有那句说走就走的旅游和世界那么大我想要出去走走，这些冠冕堂皇理由。鸿渐放手，气鼓鼓坐在那张椅子里道：“现在还不是一样的吵嘴！你要我留在旅馆里陪你，为什么那时候不老实说，我又不是你肚子里的蛔虫，知道你存什么心思！” 柔嘉回过脸来，幽远地说：“你真是爱我，不用我说，就会知道。唉！这是勉强不来的。要等我说了，你才体贴到，那就算了！…”所以说我总是不够爱你 = =?天下只有两种人。譬如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留在最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实上适得其反，缘故是第二种人还有希望，第一种人只有回忆。他记得三国演义里的名言：”妻子如衣服”,当然衣服也就等于妻子；他现在新添了皮外套，损失了个把老婆才不放在心上。我想能这种交易市场入口在哪儿？苏小姐送到客堂门口，鸿渐下阶，她唤”鸿渐“，鸿渐回来问她什么事，她笑道：”没有什么。”我在这儿望你，你为什么直望前跑，头都不回？哈哈，我真是没道理的女人，要你背后生眼睛–明天早些来。男人与女人之前的感情就是那么奇怪？装作鸿渐来一场独白。 我生怕回了头，你却会错了意。便直直的走。可你又唤我，我又怕假装听不见，伤了你的新。只要回来装模做样一番。我今天出去回来都没坐车，这东西是我省下来的车钱买的。当然我有钱买水果，可是省下钱来买，好像那才算得真正是我给你的。会不会这句情话听的猝不及防。那种感情，追想起来也可怕，把人扰乱得做事吃饭睡觉都没有心思，一刻都不饶人，简直就是神经病，真要不得！不过，生这种病有它的快乐，有时宁可再生一次病。单身狗……我知道她难看，可是因为她是我们的恩人，我不忍细看她。对于丑人，细看是一种残忍。看到此处，我想上天有好生之德，难怪我2米开外人畜不分。“……话是空的，人是活的；不是人照着话做，是话跟着人变。假如说了一句话，就至死不变的照做，世界上没有解约、反悔、道歉、离婚许多事了。”“有时一个人，并不想说谎话，说话以后，环境转变，他也不得不改变原来的意向……我有一个印象，我们在社会上一切说话全像戏院子的入场券，一边印着‘过期作废’，可是那一边并不注明什么日期，随我们的便可以提早或延迟。”]]></content>
      <categories>
        <category>我思故我在</category>
        <category>文章漫游</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>读书感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[霸王别姬]]></title>
    <url>%2Fmovie%2Fbwbj.html</url>
    <content type="text"><![CDATA[小尼姑年方二八，正青春被师傅剃去了头发，我本是男儿郎，又不是女娇娥。从男儿郎到女娇娥的转变，便是小豆子一生对于入戏至深的态度，不疯魔不成活，可惜霸王却不是真正的霸王。十一年后再相遇，尾声唱到了高潮，蝶衣永远的活在戏里，正如他的梦想，是幻灭也好，实现也罢，印证师傅的那句从一而终，自个儿成全自个儿。影片中的各种角儿，无不例外，都逃不过命运的摆布，时代的落幕便将所有的遗迹全带了去，一尘不染。兵荒马乱政局动荡年代，若不是为一口营生，谁愿意去做那下九流的生意。妓女与戏子的相遇，却如尖刀横梗在霸王与虞姬之间，纠缠的爱恨情仇，却换来的是所有的幻灭。 谁说，婊子无情，戏子无意？ 菊仙需要的是能够在危难关头拍砖解救的荡气回肠，而不是为求自保划清界限的懦弱，最后所有的坚强都留在三寸白绫上。蝶衣对于师哥依赖。错就错在将宝剑戏言当成诺言，换来的是疯魔的不屑。错就错在是入戏太深，最终换来的所有人的背叛。时光再回到十一年后，幡然醒悟错了一辈子，他本是男儿郎，又不是女娇娥。但往事已去，就随着这场戏一起落幕罢。汉兵已略地，四方楚歌声；大王意气尽，贱妾何聊生。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>影视杂谈</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>电影</tag>
        <tag>悲剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《万历十五年》]]></title>
    <url>%2Fbook%2Fwl15yew.html</url>
    <content type="text"><![CDATA[世上最大的牢笼是权利。而苦苦最求的人，殊不知身陷囹圄。看到王侯将四个字总会自动补上”宁有种乎”四个大字，或许是出自对内心对命运的不恭。关于帝王的梦，仅不过内心所需的泛滥，置于这片谐社会只便吐一口酸水，若是真的赶得上好时候也便悄然的偷乐。近读黄仁宇先生写的万历年间的故事，才若有所思。站在王朝顶端的皇帝，如同棋盘上的棋子，又如同刻在石板上飞禽走兽。真正支撑帝国运转的是——经过长期修订的君子之道。而此道凶险异常，稍有差池就堕入与之想悖的小人之道。自古以来，挺而走险帝王就离伏法不远矣，反之便练就了一身金刚不坏之躯。想来这种圣人的论辩是多么的虚妄，难怪双拳难敌四面八方来的阴骘。万历在10岁时便被剥夺了书写的乐趣，而维系王朝的工作极端繁琐，身心均被道德束缚，只得唯唯诺诺奉承。看不到半点遐想中一代帝王颐指气使作威作福的架势，就连微不足道的表情都得必须表演到位，稍有疏忽，道德之威名便张开腥盆血口。我想优柔寡断必是时代强加的，因为所有的决定都是不容置喙。所幸，有生之年还能遇到精神共通之人。话说，无需浪荡便可寻花弄柳，不过是下半身思考的措辞，而又有谁愿意被关笼中，静候死亡的降临。且不说满清政府被船尖利炮打的如丧家之犬。那记颓然之气，传到我这儿就觉得莫名其妙。汉人为何屈服于外族统治，甚至甘愿卖命。也不便额手称庆。对比外部的侵略，作为帝王受到来自内部维系王朝的屈辱还不如亡国罢了。可能生而为人总有自己劫需渡，而能做的就是静静的等待罢了。无论做什么，都不重要，时光才是最大的敌人。最后谈谈历史观，显然不能从一件历史事件来衡量人物或是评价朝代的荣辱，未免狭隘。汉人最末的王朝，也不便将千古骂名安在某人某事上，因为这便是时代风气与局限性。个人的力量太过渺小，仅此而已。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>文章漫游</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>读书感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(七)中断流程2]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio7_irq_flow2.html</url>
    <content type="text"><![CDATA[中间我们插播了一下通用中断子系统的内容，补了一下基础知识，现在回到代码中。 开始前又要打断一下，我们先回顾一下之前分析的代码： 我们试图 从GPIO1_1 管脚的中断找到通过内核 API : request_irq 注册的中断处理函数。我们关注4部分的处理： CPU的中断处理函数[mechine] GIC的中断处理函数 GPIO控制器处理函数 驱动程序注册的中断处理函数 在(五)中我们已经分析到 generic_handle_irq 函数，这部分是指CPU的中断处理，从中断向量到 generic_handle_irq 函数,那么我们继续走。 1234567891011121314//kernel/irq/irqdesc.c int generic_handle_irq(unsigned int irq)&#123; struct irq_desc *desc = irq_to_desc(irq); if (!desc) return -EINVAL; generic_handle_irq_desc(irq, desc); return 0;&#125;static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)&#123; desc-&gt;handle_irq(irq, desc);&#125; GPIO1_1的设备描述符的初始化这里我们发现通过 irq_to_desc 我们找到该中断的中断描述符，然后调用了用 中段描述符中记录的 high_level handle这里我们得先看看我们关于 GPIO1_1 的中断描述符是什么时候申请并存放到系统的 中断描述符表 中的呢？ GPIO1_1的设备描述符分配所以我们现在关心两个方面的内容： 系统中断号的分配 handle_irq 也就是 high level 处理函数的初始化 我们想起来我们在最开始分析GPIOLIB库的时候当时跳过的中断的一些内容，当时我们还看不懂中断操作的意义，现在在退回去看看。 1234//driver/gpio/gpio-mxc.c//mxc_gpio_probeirq_base = irq_alloc_descs(-1, 0, 32, numa_node_id()); //申请了32个中断描述符mxc_gpio_init_gc(port, irq_base); // init gpio_generc_control 这里只有两行代码,我们先分析申请中断描述符部分： 12#define irq_alloc_descs(irq, from, cnt, node) \ __irq_alloc_descs(irq, from, cnt, node, THIS_MODULE) 我们展开宏就得到了 __irq_alloc_descs(-1,0,32,numa_node_id(),THIS_MODULE); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);int __ref __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,struct module *owner)&#123; int start, ret; if (!cnt) return -EINVAL; if (irq &gt;= 0) &#123; if (from &gt; irq) return -EINVAL; from = irq; &#125; else &#123; from = arch_dynirq_lower_bound(from); &#125; mutex_lock(&amp;sparse_irq_lock); start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS, from, cnt, 0); ret = -EEXIST; if (irq &gt;=0 &amp;&amp; start != irq) goto err; if (start + cnt &gt; nr_irqs) &#123; ret = irq_expand_nr_irqs(start + cnt); if (ret) goto err; &#125; bitmap_set(allocated_irqs, start, cnt); mutex_unlock(&amp;sparse_irq_lock); return alloc_descs(start, cnt, node, owner);&#125;static int alloc_descs(unsigned int start, unsigned int cnt, int node,struct module *owner)&#123; struct irq_desc *desc; int i; for (i = 0; i &lt; cnt; i++) &#123; desc = alloc_desc(start + i, node, owner); if (!desc) goto err; mutex_lock(&amp;sparse_irq_lock); irq_insert_desc(start + i, desc);//将中断描述符存到中断描述符表中 mutex_unlock(&amp;sparse_irq_lock); &#125; return start;&#125;static struct irq_desc *alloc_desc(int irq, int node, struct module *owner)&#123; struct irq_desc *desc; gfp_t gfp = GFP_KERNEL; desc = kzalloc_node(sizeof(*desc), gfp, node); if (!desc) return NULL; /* allocate based on nr_cpu_ids */ desc-&gt;kstat_irqs = alloc_percpu(unsigned int); if (!desc-&gt;kstat_irqs) goto err_desc; if (alloc_masks(desc, gfp, node)) goto err_kstat; raw_spin_lock_init(&amp;desc-&gt;lock); lockdep_set_class(&amp;desc-&gt;lock, &amp;irq_desc_lock_class); desc_set_defaults(irq, desc, node, owner);//给中断描述符设置默认的参数 return desc;err_kstat: free_percpu(desc-&gt;kstat_irqs);err_desc: kfree(desc); return NULL;&#125; 这里系统是通过位图来存放系统的中断号，这里我们一口气申请了32个中断号，因为GPIO1控制器上有32个管脚都可以做中断使用。 我们分别看一下两个函数： desc_set_defaults //填充默认的参数 irq_insert_desc // 将描述符存到描述符表中 12345678910111213141516171819202122static void desc_set_defaults(unsigned int irq, struct irq_desc *desc, int node, struct module *owner)&#123; int cpu; desc-&gt;irq_data.irq = irq; desc-&gt;irq_data.chip = &amp;no_irq_chip; desc-&gt;irq_data.chip_data = NULL; desc-&gt;irq_data.handler_data = NULL; desc-&gt;irq_data.msi_desc = NULL; irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS); irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_DISABLED); desc-&gt;handle_irq = handle_bad_irq; desc-&gt;depth = 1; desc-&gt;irq_count = 0; desc-&gt;irqs_unhandled = 0; desc-&gt;name = NULL; desc-&gt;owner = owner; for_each_possible_cpu(cpu) *per_cpu_ptr(desc-&gt;kstat_irqs, cpu) = 0; desc_smp_init(desc, node);&#125; 这里我们看到默认的参数几乎都是没用的参数，说明了后续我们需要一步步填充这些参数。下面我们看看如何存储的，因为我们配置了CONFIG_RADIX_TREE我们之前说过设备描述符的存储方式有两种 静态的数组 radix_tree 我们可以看到代码很简单，就是将irq作为关键字和对应的数据描述符存到基树中然后我们通过irq 使用 irq_to_desc 函数就能找到数据描述符。123456789101112static RADIX_TREE(irq_desc_tree, GFP_KERNEL);static void irq_insert_desc(unsigned int irq, struct irq_desc *desc)&#123; radix_tree_insert(&amp;irq_desc_tree, irq, desc);&#125;struct irq_desc *irq_to_desc(unsigned int irq)&#123; return radix_tree_lookup(&amp;irq_desc_tree, irq);&#125; GPIO1_1的中断处理函数初始化好！我们该去看看初始化 mxc_gpio_init_gc了。 1234567891011121314151617static void __init mxc_gpio_init_gc(struct mxc_gpio_port *port, int irq_base)&#123; struct irq_chip_generic *gc; struct irq_chip_type *ct; gc = irq_alloc_generic_chip("gpio-mxc", 1, irq_base, port-&gt;base, handle_level_irq); gc-&gt;private = port; ct = gc-&gt;chip_types; ct-&gt;chip.irq_ack = irq_gc_ack_set_bit; ct-&gt;chip.irq_mask = irq_gc_mask_clr_bit; ct-&gt;chip.irq_unmask = irq_gc_mask_set_bit; ct-&gt;chip.irq_set_type = gpio_set_irq_type; ct-&gt;chip.irq_set_wake = gpio_set_wake_irq; ct-&gt;regs.ack = GPIO_ISR; ct-&gt;regs.mask = GPIO_IMR; irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_NESTED_LOCK, IRQ_NOREQUEST, 0);&#125; 这里我们看到是对 struct irq_chip_genericc 和 struct irq_chip_type 结构的初始化.这里irq_chip_generic是通用的中断控制器，irq_chip_type 中断控制器的类型，我们在之前一章都见到过。第6行: gc = irq_alloc_generic_chip(“gpio-mxc”, 1, irq_base, port-&gt;base, handle_level_irq); 用来分配一个通用控制器第16行: irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_NESTED_LOCK, IRQ_NOREQUEST, 0); 用来注册通用控制器 123456789101112131415161718192021struct irq_chip_generic *irq_alloc_generic_chip(const char *name, int num_ct, unsigned int irq_base, void __iomem *reg_base, irq_flow_handler_t handler)&#123; struct irq_chip_generic *gc; unsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type); gc = kzalloc(sz, GFP_KERNEL); if (gc) &#123; irq_init_generic_chip(gc, name, num_ct, irq_base, reg_base, handler); &#125; return gc;&#125;static void irq_init_generic_chip(struct irq_chip_generic *gc, const char *name, int num_ct, unsigned int irq_base,void __iomem *reg_base, irq_flow_handler_t handler)&#123; raw_spin_lock_init(&amp;gc-&gt;lock); gc-&gt;num_ct = num_ct; gc-&gt;irq_base = irq_base; gc-&gt;reg_base = reg_base; gc-&gt;chip_types-&gt;chip.name = name; gc-&gt;chip_types-&gt;handler = handler;&#125; 这里分配比较简单，就是填充了irq_chip_generic控制器的各种参数：其中最重要的是irq_flow_handler_t 类型的中断流控函数，之前我们提到过通用中断子系统实现了以下这些标准流控回调函数，这些函数都定义在：kernel/irq/chip.c中 handle_simple_irq 用于简易流控处理； handle_level_irq 用于电平触发中断的流控处理； handle_edge_irq 用于边沿触发中断的流控处理； handle_fasteoi_irq 用于需要响应eoi的中断控制器； handle_percpu_irq 用于只在单一cpu响应的中断； handle_nested_irq 用于处理使用线程的嵌套中断； 这里我们使用了电平触发方式的流控函数。最后我们看看注册的函数irq_setup_generic_chip 如何实现，这里我们看看传入了设备描述符BIT_MAP位号开始地址。 123456789101112131415161718192021222324252627282930313233343536void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk, enum irq_gc_flags flags, unsigned int clr, unsigned int set)&#123; struct irq_chip_type *ct = gc-&gt;chip_types; struct irq_chip *chip = &amp;ct-&gt;chip; unsigned int i; raw_spin_lock(&amp;gc_lock); list_add_tail(&amp;gc-&gt;list, &amp;gc_list); raw_spin_unlock(&amp;gc_lock); irq_gc_init_mask_cache(gc, flags); //为每一个中断设置流控函数 for (i = gc-&gt;irq_base; msk; msk &gt;&gt;= 1, i++) &#123; if (!(msk &amp; 0x01)) continue; if (flags &amp; IRQ_GC_INIT_NESTED_LOCK) irq_set_lockdep_class(i, &amp;irq_nested_lock_class); if (!(flags &amp; IRQ_GC_NO_MASK)) &#123; struct irq_data *d = irq_get_irq_data(i); if (chip-&gt;irq_calc_mask) chip-&gt;irq_calc_mask(d); else d-&gt;mask = 1 &lt;&lt; (i - gc-&gt;irq_base); &#125; irq_set_chip_and_handler(i, chip, ct-&gt;handler);//设置流控的函数 irq_set_chip_data(i, gc);//desc-&gt;irq_data.chip_data = data; irq_modify_status(i, clr, set);// &#125; gc-&gt;irq_cnt = i - gc-&gt;irq_base;&#125; 这里也就是为给设备描述符中的参数做初始化，我们具体的看一下，之前设置的默认参数这么块就重新设定了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static inline void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *chip, irq_flow_handler_t handle)&#123; irq_set_chip_and_handler_name(irq, chip, handle, NULL);&#125;void irq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip, irq_flow_handler_t handle, const char *name)&#123; irq_set_chip(irq, chip); //desc-&gt;irq_data.chip = chip; __irq_set_handler(irq, handle, 0, name);// desc-&gt;handle_irq = handle; // desc-&gt;name = name;&#125;void __irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,const char *name)&#123; unsigned long flags; struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, 0); if (!desc) return; if (!handle) &#123; handle = handle_bad_irq; &#125; else &#123; struct irq_data *irq_data = &amp;desc-&gt;irq_data; if (WARN_ON(!irq_data || irq_data-&gt;chip == &amp;no_irq_chip)) goto out; &#125; /* Uninstall? */ if (handle == handle_bad_irq) &#123; if (desc-&gt;irq_data.chip != &amp;no_irq_chip) mask_ack_irq(desc); irq_state_set_disabled(desc); desc-&gt;depth = 1; &#125; desc-&gt;handle_irq = handle; desc-&gt;name = name; if (handle != handle_bad_irq &amp;&amp; is_chained) &#123; irq_settings_set_noprobe(desc); //desc-&gt;status_use_accessors |= _IRQ_NOPROBE; irq_settings_set_norequest(desc);// desc-&gt;status_use_accessors |= _IRQ_NOREQUEST; irq_settings_set_nothread(desc); // desc-&gt;status_use_accessors |= _IRQ_NOTHREAD; irq_startup(desc, true); &#125;&#125; 这里我们又见到 __irq_set_handler 函数了，我们之前在GIC中注册中断控制器时，传入的参数是is_chained是1，这样就区分了主中断控制器和级联的中断控制器。 好！我们接着来看 handle_level_irq 的流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687voidhandle_level_irq(unsigned int irq, struct irq_desc *desc)&#123; raw_spin_lock(&amp;desc-&gt;lock); mask_ack_irq(desc);//1.2步骤 if (!irq_may_run(desc)) goto out_unlock; desc-&gt;istate &amp;= ~(IRQS_REPLAY | IRQS_WAITING); kstat_incr_irqs_this_cpu(irq, desc); /* * If its disabled or no action available * keep it masked and get out of here */ if (unlikely(!desc-&gt;action || irqd_irq_disabled(&amp;desc-&gt;irq_data))) &#123; desc-&gt;istate |= IRQS_PENDING; goto out_unlock; &#125; handle_irq_event(desc); cond_unmask_irq(desc);//步骤3out_unlock: raw_spin_unlock(&amp;desc-&gt;lock);&#125;irqreturn_t handle_irq_event(struct irq_desc *desc)&#123; struct irqaction *action = desc-&gt;action; irqreturn_t ret; desc-&gt;istate &amp;= ~IRQS_PENDING; irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);// raw_spin_unlock(&amp;desc-&gt;lock); ret = handle_irq_event_percpu(desc, action); raw_spin_lock(&amp;desc-&gt;lock); irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS); return ret;&#125;irqreturn_thandle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)&#123; irqreturn_t retval = IRQ_NONE; unsigned int flags = 0, irq = desc-&gt;irq_data.irq; do &#123; irqreturn_t res; trace_irq_handler_entry(irq, action); res = action-&gt;handler(irq, action-&gt;dev_id); trace_irq_handler_exit(irq, action, res); if (WARN_ONCE(!irqs_disabled(),"irq %u handler %pF enabled interrupts\n", irq, action-&gt;handler)) local_irq_disable(); switch (res) &#123; case IRQ_WAKE_THREAD: __irq_wake_thread(desc, action); /* Fall through to add to randomness */ case IRQ_HANDLED: flags |= action-&gt;flags; break; default: break; &#125; retval |= res; action = action-&gt;next; &#125; while (action); add_interrupt_randomness(irq, flags); if (!noirqdebug) note_interrupt(irq, desc, retval); return retval;&#125; 我们总结一下流程handle_level_irq,最后就调用desc中 action-&gt;handler ，也就是之前提的 specific handler ：12345handle_level_irq(irq, desc) handle_irq_event(desc); struct irqaction *action = desc-&gt;action; handle_irq_event_percpu(desc, action); res = action-&gt;handler(irq, action-&gt;dev_id); 中断控制器(GPIO1)的设备描述符初始化分析到这里总觉得怪怪的，恭喜你看出了一点端倪。我们之前设备树中看到的中断号明明是66、67 ,这里怎么是随意的分配的呢？是了,我们这个驱动程序写的略微让人感到迷惑!驱动的做法是将GPIO1控制器的中断与IO口的中断做了一个分离,GPIO1的中断号是66、67 GPIO1_1—-GPIO1_16的中断号是后面又分配的。也就是说驱动发生后,GIC只知道66或67号硬件中断发生了,至于哪里GPIO1控制器他的哪个管脚根本就不关心。那么哪一个GPIO口发生的由GPIO1控制去全权负责!所以我们刚看到的一系列分析还少了一步,！按照之前的逻辑我们也看两个步骤 系统中断号的分配[这里是硬件编号为66、67的虚拟中断号的分配] handle_irq 也就是 high level 处理函数的初始化 [GPIO1的中断处理函数] 中断控制器(GPIO1)的中断号的分配我们在gic_init时，当发现中断控制器的父节点是自己时，那么说明自己是主中断控制器，那么将自己的父节点设置为NULL,初始化的时会将这个参数传入初始化函数。 12345678910for_each_matching_node(np, matches) &#123; desc-&gt;dev = np; desc-&gt;interrupt_parent = of_irq_find_parent(np); if (desc-&gt;interrupt_parent == np) desc-&gt;interrupt_parent = NULL; list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list); &#125;&#125; ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent); 在GIC初始化的代码gic_init_bases中，这里node=NULL先读gic_irqs支持的中断数量然后用函数irq_alloc_descs分配了从16开始的gic_irqs个中断描述符，这样所有连接到GIC的设备使用时候直接指定highl_level的控制函数。 12345678910111213141516171819202122232425262728gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) &amp; 0x1f; gic_irqs = (gic_irqs + 1) * 32; if (gic_irqs &gt; 1020) gic_irqs = 1020; gic-&gt;gic_irqs = gic_irqs; if(node) &#123; /* DT case */ gic-&gt;domain = irq_domain_add_linear(node, gic_irqs, &amp;gic_irq_domain_hierarchy_ops, gic); &#125; else &#123; /* Non-DT case */ /* * For primary GICs, skip over SGIs. * For secondary GICs, skip over PPIs, too. */ if (gic_nr == 0 &amp;&amp; (irq_start &amp; 31) &gt; 0) &#123; hwirq_base = 16; if (irq_start != -1) irq_start = (irq_start &amp; ~31) + 16; &#125; else &#123; hwirq_base = 32; &#125; gic_irqs -= hwirq_base; /* calculate # of irqs to allocate */ irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id()); 中断控制器(GPIO1)的中断处理函数的初始化123456789101112131415static int mxc_gpio_probe(struct platform_device *pdev)&#123; .... port-&gt;irq_high = platform_get_irq(pdev, 1); port-&gt;irq = platform_get_irq(pdev, 0); ... irq_set_chained_handler(port-&gt;irq, mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq, port); if (port-&gt;irq_high &gt; 0) &#123; /* setup handler for GPIO 16 to 31 */ irq_set_chained_handler(port-&gt;irq_high,mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq_high, port); &#125; ....&#125; 在mxc_gpio_probe中,我们看到获取中断号,然后使用 irq_set_chained_handler 注册 1234567891011121314151617181920212223242526272829static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)&#123; u32 irq_stat; struct mxc_gpio_port *port = irq_get_handler_data(irq); struct irq_chip *chip = irq_get_chip(irq); chained_irq_enter(chip, desc); irq_stat = readl(port-&gt;base + GPIO_ISR) &amp; readl(port-&gt;base + GPIO_IMR); mxc_gpio_irq_handler(port, irq_stat); chained_irq_exit(chip, desc);&#125;static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)&#123; while (irq_stat != 0) &#123; int irqoffset = fls(irq_stat) - 1; if (port-&gt;both_edges &amp; (1 &lt;&lt; irqoffset)) mxc_flip_edge(port, irqoffset); generic_handle_irq(irq_find_mapping(port-&gt;domain, irqoffset)); irq_stat &amp;= ~(1 &lt;&lt; irqoffset); &#125;&#125; 我们看GPIO_1控制器的中断处理函数中再一次调用了generic_handle_irq ，是不是很眼熟哇！饶了一个圈子!!! 然后才迫使GPIO1_1的中断处理程序得到了调用。 GPIO中断控制器的调用逻辑小结总结一下,中断处理流程是 电信号CPU触发中断 CPU差中断向量最后跳入了GIC的中断处理函数 GIC中断处理函数通过GIC状态字寄存器得知外设发生中断(GPIO1控制器),也就是知道了硬件GIC硬件中断编号，然后通过 irq_find_mapping找到了中断描述符 ,接着调用了 generic_handle_irq(irq) 也就是high_level handle(GPIO1控制器的中断处理函数) GPIO1控制器注册的控制函数为 mx3_gpio_irq_handler ,(这个处理过程与GIC的处理方法类似),找到了哪个IO口触发中断，然后通过 irq_find_mapping找到GPIO1_1的中断号，也就是找到了GPIO1_1中断描述符，然后调用generic_handle_irq（GPIO_1_1） 最后运行了刚刚我们分析的 handle_level_irq 函数 最后调用了驱动程序的中断例程！ 驱动程序中的中断例程注册现在我们来看desc的参数action是什么时候初始化上来的？ 现在我们来分析一下非常常用的API: request_irq 这里一共有5个参数： irq 需要申请的irq编号，我们通常会用gpio2irq()去获取 handler 中断服务回调函数，该回调运行在中断上下文中 thread_fn 如果该参数不为NULL，内核会为该irq创建一个内核线程。 flags 控制中断行为的位标志，如触发方式、共享中断等 name 申请本中断服务的设备名称，同时也作为中断线程的名称。 dev 当多个设备的中断线共享同一个irq时，它会作为handler的参数，用于区分不同的设备。 这里做了irqflags的合理校验后填充 irqaction 结构，最后把大部分工作委托给__setup_irq函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)&#123; return request_threaded_irq(irq, handler, NULL, flags, name, dev);&#125;int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)&#123; struct irqaction *action; struct irq_desc *desc; int retval; if (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) || (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) || ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND))) return -EINVAL; desc = irq_to_desc(irq); if (!desc) return -EINVAL; if (!irq_settings_can_request(desc) || WARN_ON(irq_settings_is_per_cpu_devid(desc))) return -EINVAL; if (!handler) &#123; if (!thread_fn) return -EINVAL; handler = irq_default_primary_handler; &#125; action = kzalloc(sizeof(struct irqaction), GFP_KERNEL); if (!action) return -ENOMEM; action-&gt;handler = handler; action-&gt;thread_fn = thread_fn; action-&gt;flags = irqflags; action-&gt;name = devname; action-&gt;dev_id = dev_id; chip_bus_lock(desc); retval = __setup_irq(irq, desc, action); chip_bus_sync_unlock(desc); if (retval) kfree(action); return retval;&#125; 这个处理比较长，我们看一下重点：如果action不为空，说明了是共享中断1234567891011121314151617181920212223242526272829old_ptr = &amp;desc-&gt;action; old = *old_ptr; if (old) &#123; if (!((old-&gt;flags &amp; new-&gt;flags) &amp; IRQF_SHARED) || ((old-&gt;flags ^ new-&gt;flags) &amp; IRQF_TRIGGER_MASK) || ((old-&gt;flags ^ new-&gt;flags) &amp; IRQF_ONESHOT)) goto mismatch; /* All handlers must agree on per-cpuness */ if ((old-&gt;flags &amp; IRQF_PERCPU) != (new-&gt;flags &amp; IRQF_PERCPU)) goto mismatch; /* add new interrupt at end of irq queue */ do &#123; /* * Or all existing action-&gt;thread_mask bits, * so we can find the next zero bit for this * new action. */ thread_mask |= old-&gt;thread_mask; old_ptr = &amp;old-&gt;next; old = *old_ptr; &#125; while (old); shared = 1; &#125; 如果这不是一个共享中断，或者是共享中断的第一次申请，函数将初始化irq_desc结构中断线程等待结构：wait_for_threads，disable_irq函数会使用该字段等待所有irq线程的结束。接下来设置中断控制器的电气触发类型，然后处理一些必要的IRQF_XXXX标志位最后将将 irqaction 挂到了链表上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354if (!shared) &#123; ret = irq_request_resources(desc); init_waitqueue_head(&amp;desc-&gt;wait_for_threads); /* Setup the type (level, edge polarity) if configured: */ if (new-&gt;flags &amp; IRQF_TRIGGER_MASK) &#123; ret = __irq_set_trigger(desc, irq, new-&gt;flags &amp; IRQF_TRIGGER_MASK); if (ret) goto out_mask; &#125; desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \ IRQS_ONESHOT | IRQS_WAITING); irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS); if (new-&gt;flags &amp; IRQF_PERCPU) &#123; irqd_set(&amp;desc-&gt;irq_data, IRQD_PER_CPU); irq_settings_set_per_cpu(desc); &#125; if (new-&gt;flags &amp; IRQF_ONESHOT) desc-&gt;istate |= IRQS_ONESHOT; if (irq_settings_can_autoenable(desc)) irq_startup(desc, true); else /* Undo nested disables: */ desc-&gt;depth = 1; if (new-&gt;flags &amp; IRQF_NOBALANCING) &#123; irq_settings_set_no_balancing(desc); irqd_set(&amp;desc-&gt;irq_data, IRQD_NO_BALANCING); &#125; /* Set default affinity mask once everything is setup */ setup_affinity(irq, desc, mask); &#125;new-&gt;irq = irq;*old_ptr = new; //把新的irqaction实例链接到action链表的最后irq_pm_install_action(desc, new);/* Reset broken irq detection when installing new handler */desc-&gt;irq_count = 0;desc-&gt;irqs_unhandled = 0;register_irq_proc(irq, desc);new-&gt;dir = NULL;register_handler_proc(irq, new);free_cpumask_var(mask); 这样将就把通用子系统的中断响应流程给走通了。 后记这个调用流程和普通外设相比多了调用的流程，起初分析的时候比较困惑。后来想到了多中断控制器级联后，豁然开朗。接着一气呵成，感觉写的内容超过之前的所有。囧!豁然开朗!!!!!]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(六)通用中断控制器的软件抽象]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio6_intsubsystem.html</url>
    <content type="text"><![CDATA[Linux通用中断子系统前面我们介绍过引入 irq_domain 的概念目的是屏蔽中断控制器的细节(IRQ号与硬件连线的关系),但我们没有分析过中断控制器的细节是咋样的。前面我们提到过：ARM的中断控制器GIC,GPIO控制器也是一个中断控制器，还有一面之缘的GPC控制器。这么多不同的中断控制器，我们需要将一些特性抽象出来，才能统一的操作这些中断控制器。所以Linux引入了通用中断子系统(Generic irq).这里通用中断子系统主要分成了三个层次：驱动程序中断逻辑层硬件封装层硬件封装层它包含了体系架构相关的所有代码，包括中断控制器的抽象封装，arch相关的中断初始化，以及各个IRQ的相关数据结构的初始化工作，cpu的中断入口也会在arch相关的代码中实现。中断通用逻辑层通过标准的封装接口（实际上就是struct irq_chip定义的接口）访问并控制中断控制器的行为，体系相关的中断入口函数在获取IRQ编号后，通过中断通用逻辑层提供的标准函数，把中断调用传递到中断流控层中。123456789101112131415161718192021struct irq_chip &#123; const char *name; unsigned int (*irq_startup)(struct irq_data *data); //第一次开启一个irq时使用。 void (*irq_shutdown)(struct irq_data *data); void (*irq_enable)(struct irq_data *data); // 使能该irq void (*irq_disable)(struct irq_data *data); //禁用改irq void (*irq_mask)(struct irq_data *data); // 屏蔽该irq void (*irq_unmask)(struct irq_data *data); // 取消屏蔽该irq void (*irq_ack)(struct irq_data *data); //用于CPU对该irq的回应，通常表示cpu希望要清除该irq的pending状态，准备接受下一个irq请求。 void (*irq_mask_ack)(struct irq_data *data); //相当于irq_mask + irq_ack void (*irq_eoi)(struct irq_data *data); //有些中断控制器需要在cpu处理完该irq后发出eoi信号，该回调就是用于这个目的 int (*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force); // 用于设置该irq和cpu之间的亲缘关系，就是通知中断控制器，该irq发生时，那些cpu有权响应该irq。当然，中断控制器会在软件的配合下，最终只会让一个cpu处理本次请求。 int (*irq_retrigger)(struct irq_data *data); int (*irq_set_type)(struct irq_data *data, unsigned int flow_type); //设置irq的电气触发条件，例如IRQ_TYPE_LEVEL_HIGH或IRQ_TYPE_EDGE_RISING。 int (*irq_set_wake)(struct irq_data *data, unsigned int on); //通知电源管理子系统，该irq是否可以用作系统的唤醒源。 ...... &#125;;这里我们看得出 irq_chip 它实际上就是对中断控制器的接口抽象，我们实现每个硬件中断控制器我们只需实现irq_chip中的部分接口即可。中断通用逻辑在之前我们已经介绍过这张图了，现在我们再详细的介绍解读一下。首先我们需要先组织好irq_desc表格，我们称它是 中断描述符表。[历史原因]实际实现有两种:静态表格radix树我们知道数组的缺点需要连续，这样回造成浪费。所以我们引入了radix树来存储。当发生中断后，首先获取触发中断的HW interupt ID，然后通过irq domain翻译成IRQ nuber，然后通过IRQ number就可以获取对应的中断描述符。调用中断描述符中的highlevel irq-events handler来进行中断处理就OK了。而highlevel irq-events handler主要进行下面两个操作：调用中断描述符的底层irq chip driver进行mask，ack等callback函数，进行interrupt flow control。调用该中断描述符上的action list中的specific handler（我们用这个术语来区分具体中断handler和high level的handler）。这个步骤不一定会执行，这是和中断描述符的当前状态相关，实际上，interrupt flow control是软件（设定一些标志位，软件根据标志位进行处理）和硬件（mask或者unmask interrupt controller等）一起控制完成的。接下来我们看看相关的数据结构来再次加深对这段话的理解。首先先看 中断描述符1234567891011121314151617181920212223242526struct irq_desc &#123; struct irq_data irq_data; //与中断相关的所有数据 unsigned int __percpu *kstat_irqs; irq_flow_handler_t handle_irq; //highlevel irq-events handle#ifdef CONFIG_IRQ_PREFLOW_FASTEOI irq_preflow_handler_t preflow_handler; #endif struct irqaction *action; //specific handler：中断响应链表，当一个irq被触发时，内核会遍历该链表，主要为了实现中断的共享 unsigned int status_use_accessors; unsigned int depth; /* nested irq disables */ unsigned int wake_depth; /* nested wake enables */ unsigned int irq_count; /* For detecting broken IRQs */ raw_spinlock_t lock; struct cpumask *percpu_enabled; #ifdef CONFIG_SMP const struct cpumask *affinity_hint; struct irq_affinity_notify *affinity_notify; #ifdef CONFIG_GENERIC_PENDING_IRQ cpumask_var_t pending_mask; #endif #endif wait_queue_head_t wait_for_threads; const char *name; &#125; ____cacheline_internodealigned_in_smp;接着看看irq_data这个结构：1234567891011121314struct irq_data &#123; unsigned int irq; //中断号 unsigned long hwirq; //硬件中断号 unsigned int node; //通常用于hwirq和irq之间的映射操作。 unsigned int state_use_accessors; struct irq_chip *chip; //中断控制器 struct irq_domain *domain; //中断域 void *handler_data; //每个irq的私有数据指针，该字段由硬件封转层使用，例如用作底层硬件的多路复用中断。 void *chip_data; //中断控制器的私有数据，该字段由硬件封转层使用 struct msi_desc *msi_desc; //于PCIe总线的MSI或MSI-X中断机制#ifdef CONFIG_SMP cpumask_var_t affinity; //记录该irq与cpu之间的亲缘关系#endif &#125;;这里我们看到大量和中断的结构：其中最重要的两个结构:struct irq_chipstruct irq_domain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct irq_domain &#123; struct list_head link; const char *name; const struct irq_domain_ops *ops; void *host_data; unsigned int flags; /* Optional data */ struct device_node *of_node; struct irq_domain_chip_generic *gc;#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY struct irq_domain *parent;#endif /* reverse map data. The linear map gets appended to the irq_domain */ irq_hw_number_t hwirq_max; unsigned int revmap_direct_max_irq; unsigned int revmap_size; struct radix_tree_root revmap_tree; unsigned int linear_revmap[];&#125;;struct irq_domain_chip_generic &#123; unsigned int irqs_per_chip; unsigned int num_chips; unsigned int irq_flags_to_clear; unsigned int irq_flags_to_set; enum irq_gc_flags gc_flags; struct irq_chip_generic *gc[0];&#125;;struct irq_chip_generic &#123; raw_spinlock_t lock; void __iomem *reg_base; u32 (*reg_readl)(void __iomem *addr); void (*reg_writel)(u32 val, void __iomem *addr); unsigned int irq_base; //* unsigned int irq_cnt; u32 mask_cache; u32 type_cache; u32 polarity_cache; u32 wake_enabled; u32 wake_active; unsigned int num_ct; void *private; unsigned long installed; unsigned long unused; struct irq_domain *domain; struct list_head list; struct irq_chip_type chip_types[0];&#125;;struct irq_chip_type &#123; struct irq_chip chip; struct irq_chip_regs regs; irq_flow_handler_t handler; u32 type; u32 mask_cache_priv; u32 *mask_cache;&#125;;接着我们把所有irq_chip 和irq_domin有关的数据结构都列了出来，看起来逻辑关系还比较复杂。我们只能大致的看到irq_domin存放了当前irq_chip的类型（通常是一种）和一些状态信息。我们暂且不要管太多现在知道了几个数据结构就可以，后面在代码中在去理清这些联系。IRQ中断流控因为各种中断请求的电气特性会有所不同，又或者中断控制器的特性也不同，这会导致以下这些处理也会有所不同：何时对中断控制器发出ack回应；mask_irq和unmask_irq的处理；中断控制器是否需要eoi回应？何时打开cpu的本地irq中断？以便允许irq的嵌套；中断数据结构的同步和保护；目前的通用中断子系统实现了以下这些标准流控回调函数，这些函数都定义在：kernel/irq/chip.c中handle_simple_irq 用于简易流控处理；handle_level_irq 用于电平触发中断的流控处理；handle_edge_irq 用于边沿触发中断的流控处理；handle_fasteoi_irq 用于需要响应eoi的中断控制器；handle_percpu_irq 用于只在单一cpu响应的中断；handle_nested_irq 用于处理使用线程的嵌套中断；我们在 中断描述符结构中已经看到 highlevel irq-events handle：irq_flow_handler_t handle_irq;typedef void (irq_flow_handler_t)(unsigned int irq, struct irq_desc desc);这样与通用子系统的相关的内容就快速的介绍了一遍，我们先休息一下，跳进代码中。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(五)中断处理流程1]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio5_irq_flow1.html</url>
    <content type="text"><![CDATA[Linux每一个外设的中断都由 struct irq_desc 来描述，我们称之中断描述符。这里我们将中断描述符组织在一起形成一个中断描述符表。这里在老版本的内核中,习惯用静态的数组来维护所有的中断描述符。在引入设备树之后，往往我们用动态的方式维护使用函数irq_desc_alloc来分配中断描述符。当中断发生后，我们硬件中断的编码，然后通过irq domain翻译成IQR Number,最终找到设备描述符继而调用highlevel irq-events，最终调用到对应的中断处理程序。这里 high_level irq 是中断控制器的中断处理程序的抽象。 这里话不多说我们将Linux代码的处理流程线罗列出来：首先，我们在驱动程序中使用API request_irq()注册一个关于GPIO1_1管脚的中断处理函数。我们打开中断后，当GPIO1_1出现电平变化时，中断信号从GPIO控制器经过GIC然后进入到CPU的IRQ控制线。于是我们重点关注如下四个部分的处理CPU的中断处理函数[mechine]GIC的中断处理函数GPIO控制器处理函数驱动程序注册的中断处理函数CPU中断控制当中断发生，首先是通过中断向量表。然后进入真正的处理irq_handler，中断向量表这部分比较晦涩暂不分析。1234567891011 .macro irq_handler #ifdef CONFIG_MULTI_IRQ_HANDLER ldr r1, =handle_arch_irq mov r0, sp adr lr, BSYM(9997f) ldr pc, [r1] #else arch_irq_handler_default #endif 9997: .endm这里：MULTI_IRQ_HANDLER 配置项，则意味着允许平台的代码可以动态设置irq处理程序，平台代码可以修改全局变量：handle_arch_irq，从而可以修改irq的处理程序。首先我们宏MULTI_IRQ_HANDLER的分支：我们之前分析过arm,cortex-a9-gic的代码，我们看看这个中断控制器是如何将中断控制函数给注册上去。1234IRQCHIP_DECLARE(cortex_a9_gic, &quot;arm,cortex-a9-gic&quot;, gic_of_init);gic_of_init gic_init_bases set_handle_irq(handle_irq)我们之前在(三)中分析过：作为second GIC，需要调用 irq_set_chained_handler 注册irq_handler到root GIC中。作为root GIC，上级是CPU，调用 set_handle_irq 注册到平台的irq处理接口。12345678910//kernel/irq.c#ifdef CONFIG_MULTI_IRQ_HANDLERvoid __init set_handle_irq(void (*handle_irq)(struct pt_regs *))&#123; if (handle_arch_irq) return; handle_arch_irq = handle_irq;&#125;#endif然后GIC的中断处理最终进入 __handle_domain_irq 函数。12345678910111213141516171819202122232425262728293031static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)&#123; u32 irqstat, irqnr; struct gic_chip_data *gic = &amp;gic_data[0]; void __iomem *cpu_base = gic_data_cpu_base(gic); do &#123; irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK); irqnr = irqstat &amp; GICC_IAR_INT_ID_MASK; if (likely(irqnr &gt; 15 &amp;&amp; irqnr &lt; 1021)) &#123; handle_domain_irq(gic-&gt;domain, irqnr, regs); continue; &#125; if (irqnr &lt; 16) &#123; writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);#ifdef CONFIG_SMP handle_IPI(irqnr, regs);#endif continue; &#125; break; &#125; while (1);&#125;//include/liniux/irq_desc.hstatic inline int handle_domain_irq(struct irq_domain *domain, unsigned int hwirq, struct pt_regs *regs)&#123; return __handle_domain_irq(domain, hwirq, true, regs);&#125;然后我们再接着看ELSE分支的arch_irq_handler_default1234567891011121314151617181920212223//arch/arm/include/asm/entry_macro_multi.S.macro arch_irq_handler_default get_irqnr_preamble r6, lr 1: get_irqnr_and_base r0, r2, r6, lr movne r1, sp @ @ routine called with r0 = irq number, r1 = struct pt_regs * @ adrne lr, BSYM(1b) bne asm_do_IRQ //arch/arm/kernel/irq.casmlinkage void __exception_irq_entry asm_do_IRQ(unsigned int irq, struct pt_regs *regs) &#123; handle_IRQ(irq, regs); &#125; void handle_IRQ(unsigned int irq, struct pt_regs *regs)&#123; __handle_domain_irq(NULL, irq, false, regs);&#125;这里我们看到了两条路最终合并成一条都进入到 __handle_domain_irq 函数中，这里唯一的区别是否涉及到irq_domain.我们知道irq_domain做的关系就是将IRQ number 对应到硬件HW irq。在GIC控制器初始化的时候，我们做了两件事将中断控制器加入到irq domain为irq domain建立映射关系最终真正的中断处理函数 generic_handle_irq(irq);1234567891011121314151617181920212223242526272829//kerenel/irqdesc.cint __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq, bool lookup, struct pt_regs *regs)&#123; struct pt_regs *old_regs = set_irq_regs(regs); unsigned int irq = hwirq; int ret = 0; irq_enter();#ifdef CONFIG_IRQ_DOMAIN if (lookup) irq = irq_find_mapping(domain, hwirq);#endif /* * Some hardware gives randomly wrong interrupts. Rather * than crashing, do something sensible. */ if (unlikely(!irq || irq &gt;= nr_irqs)) &#123; ack_bad_irq(irq); ret = -EINVAL; &#125; else &#123; generic_handle_irq(irq); &#125; irq_exit(); set_irq_regs(old_regs); return ret;&#125;在介绍 generic_handle_irq 之前我们需要补充一些知识。我们先回顾一下刚才的流程：中断发生后，CPU会跳转到中断向量表中查找中断处理函数的位置，然后最终ARM V7架构是irq_handler函数。[中断向量相关的地方比较晦涩先跳过吧]然后我们看了 CONFIG_MULTI_IRQ_HANDLER 的分支最后都会调用进 __handle_domain_irq函数，最后调用 generic_handle_irq。因为我们的machine imx6q的实现是定义了CONFIG_MULTI_IRQ_HANDLER，所以我们着重分析这部分内容，继续回忆一下gic_of_init是哪里被调用的。没错,就是内核初始化的时候做的工作,我们可以翻回（二）在回顾一下。123start_kernel init_IRQ() machine_desc -&gt;init_irq();好！暂时先说到这里！我们跟踪代码已经看到了CPU和GIC的对于中断做出的处理函数。GPIO控制器的处理函数和真正的中断处理函数留在后面再说。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(四)Gpio中断]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio4_gpio_irq.html</url>
    <content type="text"><![CDATA[上一篇我们大致的浏览了一下GIC的注册流程。接下来我们希望能将我们的GPIO的中断和它建立起联系，这样我们就能放心大胆的使用GPIO模块提供给我们的中断服务了。 好！我们回到Gplib库的代码，之前分析是跳过了中断注册相关的内容，这次就捡起来。试着给之前的分析搭上关系, 废话不多说了，回到代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// drivers/gpio/gpio-mxc.cstatic int mxc_gpio_probe(struct platform_device *pdev)&#123; struct device_node *np = pdev-&gt;dev.of_node; struct mxc_gpio_port *port; struct resource *iores; int irq_base; int err; mxc_gpio_get_hw(pdev); //1 port = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*port), GFP_KERNEL); if (!port) return -ENOMEM; //从设备树中获取寄存器地址，IOREMAP就是将物理地址转化称虚拟地址 iores = platform_get_resource(pdev, IORESOURCE_MEM, 0); port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores); if (IS_ERR(port-&gt;base)) return PTR_ERR(port-&gt;base); //从设备树中获取中断号,上面也解释了为啥是2个。 port-&gt;irq_high = platform_get_irq(pdev, 1); port-&gt;irq = platform_get_irq(pdev, 0); if (port-&gt;irq &lt; 0) return port-&gt;irq; //关中断，清理中断触发状态。 //中断屏蔽位的作用就是是否要关心这个中断 //中断状态位的作用就是，当中断发生了，我们需要查一下是谁发生了中断。 /* disable the interrupt and clear the status */ writel(0, port-&gt;base + GPIO_IMR); writel(~0, port-&gt;base + GPIO_ISR); if (mxc_gpio_hwtype == IMX21_GPIO) &#123; /* * Setup one handler for all GPIO interrupts. Actually setting * the handler is needed only once, but doing it for every port * is more robust and easier. */ irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler); &#125; else &#123; /* setup one handler for each entry */ //2 //函数修改父中断的流控函数，当发生中断，中断控制器会去调用这个函数 irq_set_chained_handler(port-&gt;irq, mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq, port); if (port-&gt;irq_high &gt; 0) &#123; /* setup handler for GPIO 16 to 31 */ irq_set_chained_handler(port-&gt;irq_high,mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq_high, port); &#125; &#125; //3 err = bgpio_init(&amp;port-&gt;bgc, &amp;pdev-&gt;dev, 4, port-&gt;base + GPIO_PSR, port-&gt;base + GPIO_DR, NULL, port-&gt;base + GPIO_GDIR, NULL, 0); if (err) goto out_bgio;//设置gpio和软件中断号映射的关系 port-&gt;bgc.gc.to_irq = mxc_gpio_to_irq;//设置gpio的编号基数 port-&gt;bgc.gc.base = (pdev-&gt;id &lt; 0) ? of_alias_get_id(np, "gpio") * 32 : pdev-&gt;id * 32;//将GPIO控制器计入到gpiolib驱动的链表中，也就是之后我们可以gpio_direction去操作io了 err = gpiochip_add(&amp;port-&gt;bgc.gc); if (err) goto out_bgpio_remove;//申请系统IRQ number资源，一共32个，这里从0开始搜索可用的资源。 irq_base = `irq_alloc_descs`(-1, 0, 32, numa_node_id()); if (irq_base &lt; 0) &#123; err = irq_base; goto out_gpiochip_remove; &#125;//向中断控制器注册并创建映射关系 port-&gt;domain = irq_domain_add_legacy(np, 32, irq_base, 0, &amp;irq_domain_simple_ops, NULL); if (!port-&gt;domain) &#123; err = -ENODEV; goto out_irqdesc_free; &#125;//初始化gpio中断控制器 /* gpio-mxc can be a generic irq chip */ mxc_gpio_init_gc(port, irq_base); list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports); return 0;out_irqdesc_free: irq_free_descs(irq_base, 32);out_gpiochip_remove: gpiochip_remove(&amp;port-&gt;bgc.gc);out_bgpio_remove: bgpio_remove(&amp;port-&gt;bgc);out_bgio: dev_info(&amp;pdev-&gt;dev, "%s failed with errno %d\n", __func__, err); return err;&#125; 在之前分析我们知道每一组gpio使用两个中断号,好吧还是回去看一眼dts,机型不行，看interrupts结点。好！接着看代码。 1234567891011gpio1: gpio@0209c000 &#123; compatible = &quot;fsl,imx6q-gpio&quot;, &quot;fsl,imx35-gpio&quot;; reg = &lt;0x0209c000 0x4000&gt;; interrupts = &lt;0 66 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0 67 IRQ_TYPE_LEVEL_HIGH&gt;; gpio-controller; #gpio-cells = &lt;2&gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;; &#125;; 22、23行我们把硬件中断号放到mxc_gpio_port 结构 port的 irq和irq_high成员中。哎，为什么是是两个呢，人家就是这么设计，就不要较真干嘛不只用一个解决了！31、32 这里把中断状态寄存器和中断屏蔽寄存器45、46和49、50行分别为两个中断号，设置了中断处理函数和设置了中断处理函数的参数。irq_set_chained_handlerirq_set_handler_data接着62行设置GPIO模块的中断查找函数 mxc_gpio_to_irq，也就是这两个中断发生后我们通过中断状态字寄存器去确认到底是哪个管脚被设，也就知道了哪个管脚发生了中断。77行使用了irq_domain_add_legacy来向注册中断寄存器并建立映射关系，这里和我们之前说的哪个注册和映射函数不一样，我们一会儿展开来看看把。 85行，初始化GPIO的中断控制器 mxc_gpio_init_gc 这样大致看看有点谱了，和我们之前想的比较接近。1.初始化中断控制器2.注册中断处理程序 接着我们接下来按照上面列的行号来品味一下细节。前两项没什么好说的。接着我们先看看中断处理函数mx3_gpio_irq_handler 的实现，具体的设置函数我们留到Linux中断的实现再来分析。 1234567891011121314151617static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)&#123; while (irq_stat != 0) &#123; //fls或去最高有效位（从低位往左数最后的有效bit位） //这里就是得到哪个管脚触发的中断，一一处理，而且优先级就是按照这个规则来了。 int irqoffset = fls(irq_stat) - 1; //这里的做法是为了让没有双边沿触发的芯片，用轮流高低电平触发的方式解决。 //imx6芯片忽略就好，也看了半天才看清楚原来是这样。 if (port-&gt;both_edges &amp; (1 &lt;&lt; irqoffset)) mxc_flip_edge(port, irqoffset); //irq_find_mapping 这个再说吧，先记一下 generic_handle_irq(irq_find_mapping(port-&gt;domain, irqoffset)); irq_stat &amp;= ~(1 &lt;&lt; irqoffset); &#125;&#125; 这个代码对我们之前已经看过一次，逻辑很简单，查看终端状态字和屏蔽字寄存器，考录是否要响应这个中断，最后调用generic_handle_irq函数也就是我们最终设备驱动程序中注册的真正意义的中断服务程序了。这里 irq_find_mapping 是我们第二次见了，在（三）中，我看到了这个函数的作用就是找到中断号，这里先MARK一下，我们看完中断的映射自然就知道了。 这里62行的这个函数mxc_gpio_to_irq同样是用irq_find_map这个把戏:12345678static int mxc_gpio_to_irq(struct gpio_chip *gc, unsigned offset)&#123; struct bgpio_chip *bgc = to_bgpio_chip(gc); struct mxc_gpio_port *port = container_of(bgc, struct mxc_gpio_port, bgc); return irq_find_mapping(port-&gt;domain, offset);&#125; 终于到了：irq_domain_add_legacy 这里就直接进去，废话不多，毕竟还有两个函数等着它。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//kernel/irq/irqdomain.cstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node, unsigned int size //32, unsigned int first_irq , //irq_alloc_descs(-1, 0, 32, numa_node_id()) irq_hw_number_t first_hwirq, //0 const struct irq_domain_ops *ops, //irq_domain_simple_ops void *host_data //NULL)&#123; struct irq_domain *domain; domain = __irq_domain_add(of_node, first_hwirq + size, first_hwirq + size, 0, ops, host_data); if (domain) irq_domain_associate_many(domain, first_irq, first_hwirq, size); return domain;&#125;struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,//32 irq_hw_number_t hwirq_max, int direct_max, const struct irq_domain_ops *ops, void *host_data)&#123; struct irq_domain *domain; domain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size), GFP_KERNEL, of_node_to_nid(of_node)); if (WARN_ON(!domain)) return NULL; /* Fill structure */ INIT_RADIX_TREE(&amp;domain-&gt;revmap_tree, GFP_KERNEL); domain-&gt;ops = ops; domain-&gt;host_data = host_data; domain-&gt;of_node = of_node_get(of_node); domain-&gt;hwirq_max = hwirq_max;//HW最大的值 domain-&gt;revmap_size = size;//线性映射数组长度，如果是0的话使用radix_tree domain-&gt;revmap_direct_max_irq = direct_max;//0 不是用直接映射 irq_domain_check_hierarchy(domain); mutex_lock(&amp;irq_domain_mutex); list_add(&amp;domain-&gt;link, &amp;irq_domain_list); mutex_unlock(&amp;irq_domain_mutex); pr_debug("Added domain %s\n", domain-&gt;name); return domain;&#125; 这里我们发现和我们之前看的流程区别在于domain_add的方式略微不同，建立映射调用的函数都是irq_domain_associate_many。我们的参数列一下： size =32 //线性映射且长度是32hwirq_max=32direct_max=0ops=irq_domain_simple_opshost_data=NULL这里我们关注一下irq_domain_simple_ops 的实现，估计就是映射关系了。123456789101112131415const struct irq_domain_ops irq_domain_simple_ops = &#123; .xlate = irq_domain_xlate_onetwocell,&#125;;int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr, const u32 *intspec, unsigned int intsize, unsigned long *out_hwirq, unsigned int *out_type)&#123; if (WARN_ON(intsize &lt; 1)) return -EINVAL; *out_hwirq = intspec[0]; *out_type = (intsize &gt; 1) ? intspec[1] : IRQ_TYPE_NONE; return 0;&#125; 这个函数我们暂时没发现在哪里会调用，暂时先放一一边。。 123456789101112131415161718192021222324252627282930313233343536void irq_domain_associate_many(struct irq_domain *domain,unsigned int irq_base,//irq_base irq_hw_number_t hwirq_base,//0 int count //32)&#123; int i; for (i = 0; i &lt; count; i++) &#123; irq_domain_associate(domain, irq_base + i, hwirq_base + i); &#125;&#125;int irq_domain_associate(struct irq_domain *domain, unsigned int virq, irq_hw_number_t hwirq) &#123; struct irq_data *irq_data = irq_get_irq_data(virq); int ret; mutex_lock(&amp;irq_domain_mutex); irq_data-&gt;hwirq = hwirq; irq_data-&gt;domain = domain; if (domain-&gt;ops-&gt;map) &#123; ret = domain-&gt;ops-&gt;map(domain, virq, hwirq);//调用irq domain的map callback函数 &#125; //domain-&gt;revmap_size=32 //hwirq== 0-31 if (hwirq &lt; domain-&gt;revmap_size) &#123; domain-&gt;linear_revmap[hwirq] = virq;//填写线性映射lookup table的数据 &#125; else &#123; //domain-&gt;revmap_size==0是使用redix tree mutex_lock(&amp;revmap_trees_mutex); radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);//向radix tree插入一个node mutex_unlock(&amp;revmap_trees_mutex); &#125; mutex_unlock(&amp;irq_domain_mutex); irq_clear_status_flags(virq, IRQ_NOREQUEST); //该IRQ已经可以申请了，因此clear相关flag return 0; &#125; 这里ops-&gt;map =NULLhwirq &lt; domain-&gt;revmap_size 都为32，所以采用的线性关系来做映射,接着我们看看 irq_find_mapping 是否如何找到这个映射关系的？ 12345678910111213141516171819202122232425262728unsigned int irq_find_mapping(struct irq_domain *domain, irq_hw_number_t hwirq)&#123; struct irq_data *data; /* Look for default domain if nececssary */ if (domain == NULL) domain = irq_default_domain; if (domain == NULL) return 0; //直接映射 if (hwirq &lt; domain-&gt;revmap_direct_max_irq) &#123; data = irq_domain_get_irq_data(domain, hwirq); if (data &amp;&amp; data-&gt;hwirq == hwirq) return hwirq; &#125; /* Check if the hwirq is in the linear revmap. */ //线性映射 if (hwirq &lt; domain-&gt;revmap_size) return domain-&gt;linear_revmap[hwirq]; rcu_read_lock(); //radix_tree映射 data = radix_tree_lookup(&amp;domain-&gt;revmap_tree, hwirq); rcu_read_unlock(); return data ? data-&gt;irq : 0;&#125; 这里我们使用的是线性映射，就从数组中找到了IRQ number. 最后看完mxc_gpio_init_gc函数结束此次分析： 123456789101112131415161718192021static void __init mxc_gpio_init_gc(struct mxc_gpio_port *port, int irq_base)&#123; struct irq_chip_generic *gc; struct irq_chip_type *ct; gc = irq_alloc_generic_chip("gpio-mxc", 1, irq_base, port-&gt;base, handle_level_irq); gc-&gt;private = port; ct = gc-&gt;chip_types; ct-&gt;chip.irq_ack = irq_gc_ack_set_bit; ct-&gt;chip.irq_mask = irq_gc_mask_clr_bit; ct-&gt;chip.irq_unmask = irq_gc_mask_set_bit; ct-&gt;chip.irq_set_type = gpio_set_irq_type; ct-&gt;chip.irq_set_wake = gpio_set_wake_irq; ct-&gt;regs.ack = GPIO_ISR; ct-&gt;regs.mask = GPIO_IMR; irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_NESTED_LOCK, IRQ_NOREQUEST, 0);&#125; 这里的功能是设置中断的各个寄存器的控制函数，和每一个管脚触发电平变化时的控制函数：handle_level_irq 12345678910111213141516171819202122232425262728void handle_level_irq(unsigned int irq, struct irq_desc *desc)&#123; raw_spin_lock(&amp;desc-&gt;lock); mask_ack_irq(desc); if (!irq_may_run(desc)) goto out_unlock; desc-&gt;istate &amp;= ~(IRQS_REPLAY | IRQS_WAITING); kstat_incr_irqs_this_cpu(irq, desc); /* * If its disabled or no action available * keep it masked and get out of here */ if (unlikely(!desc-&gt;action || irqd_irq_disabled(&amp;desc-&gt;irq_data))) &#123; desc-&gt;istate |= IRQS_PENDING; goto out_unlock; &#125; handle_irq_event(desc); cond_unmask_irq(desc);out_unlock: raw_spin_unlock(&amp;desc-&gt;lock);&#125; handle_irq_event 便是上报给系统发生中断的消息。 这样我们就大致理清了思路。 注册irq_domain 增加映射关系 GPIO中断器的初始化(如GPIO中断控制器的控制函数等)]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(三)ARM通用中断控制器]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio3_gic.html</url>
    <content type="text"><![CDATA[在(二)中我们走到通用中断控制器和GPC时就停下来了，我们只浏览了中断控制器匹配部分的流程还未进入真正核心的区域。因为水平有限，这里之分析GIC的部分，况且GPC和我们的主体GPIO想去甚远。GIC介绍首先，我们需要了解GIC的内部结构才能真正理解，中断是如何被处理的，最终才能理解代码。关于IMX6芯片手册关于GIC的描述只有：The Global Interrupt Controller (GIC) collects up to 128 interrupt requests from all i.MX6Dual/6Quad sources and provides an interface to each of the CPU cores和IRQ的硬件编号从32-159的对应表格，有点吝啬。我们在设备树中知道使用的是 arm,cortex-a9-gic 的这个IP.ARM平台上一般把中断分为三种类型，分别是SGI（software generated interrupts）PPI（per processor interrupts）SPI（shared processor interrupts）硬件中断号的分配：ID0~ID31是用于分发到一个特定的process的interrupt。标识这些interrupt不能仅仅依靠ID，还必须指定process的ID，因此识别这些interrupt需要interrupt ID ＋ CPU interface number。ID0~ID15属于SGI中断，SGI是通过软件写入GIC的GICD_SGIR寄存器而触发的中断，它可以用于processor之间的通信。 GIC通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。ID16~ID31属于PPI中断，PPI类型的中断和SPI一样属于外设的中断，区别就是它会被送到其私有的process上，而和其他的process无关。ID32~ID1019用于SPI。 这是GIC规范的最大范围，实际上Cortex-A15和A9上的GIC最多支持224个SPI。这里IMX6 仅使用32-159源码跟踪我们在之前的分析中知道，初始化代码是gic_of_initIRQCHIP_DECLARE(cortex_a9_gic, “arm,cortex-a9-gic”, gic_of_init);接着我们先去代码中窥探一下：为方便起见设备树被列一下：12345678intc: interrupt-controller@00a01000 &#123; compatible = "arm,cortex-a9-gic"; #interrupt-cells = &lt;3&gt;; interrupt-controller; reg = &lt;0x00a01000 0x1000&gt;, &lt;0x00a00100 0x100&gt;; interrupt-parent = &lt;&amp;intc&gt;; &#125;;12345678910111213141516171819202122232425262728293031323334353637static int __init gic_of_init(struct device_node *node, struct device_node *parent)&#123; void __iomem *cpu_base; void __iomem *dist_base; u32 percpu_offset; int irq; if (WARN_ON(!node)) return -ENODEV; dist_base = of_iomap(node, 0);//0x00a01000 -0x00a01100 WARN(!dist_base, "unable to map gic dist registers\n"); cpu_base = of_iomap(node, 1);//0x00a00100 -0x00a00200 WARN(!cpu_base, "unable to map gic cpu registers\n"); if (of_property_read_u32(node, "cpu-offset", &amp;percpu_offset)) percpu_offset = 0; gic_init_bases(gic_cnt, -1, dist_base, cpu_base, percpu_offset, node); if (!gic_cnt) gic_init_physaddr(node);//这里本身GIC就是主GIC所以这个不需要做irq_map这个过程已经推迟外设的驱动中去// interrupt-parent = &lt;&amp;intc&gt;; 这句话也相当于脱裤子放屁多次一举。 if (parent) &#123; irq = irq_of_parse_and_map(node, 0); gic_cascade_irq(gic_cnt, irq); &#125; if (IS_ENABLED(CONFIG_ARM_GIC_V2M)) gicv2m_of_init(node, gic_data[gic_cnt].domain); gic_cnt++; return 0;&#125;Linux IRQ domain这里我们先引入linux的irq domain 概念。为什么引入这个概念呢，就是因为我们可能存在多个GIC控制器，相对于过去片上的中断控制器的一一对应关系显得复杂很多。引入IRQ domain的目的就是为了简化这一层逻辑关系。这里我们将一个控制器作为一共domian.这一个domain连接的可能是外设也可能是连接另外一个控制器，同时本身也可能直接连接到CPU或者是根控制器。这样每一个domain维护自己的连接逻辑，上一层就不必操心这些问题。最后将这些复杂的逻辑简化为一共简单的列表项。IRQ number 对应的 HW irq 这样的简单逻辑关系。IRQ domian注册步骤那么我们在这个系统的上，需要建立这种关系我们需要做的事情1.将中断控制器加入到irq domain2.为irq domain建立映射关系这里将控制器加入到 irq doman是控制器驱动做的事而建立irq domain的映射关系分散在各个驱动中。为什么呢？比如GPIO1在硬件连线中已经设定了HW中断号是89，然后应该由于GPIO1控制器的驱动去更新这个映射表，我是HW 89号中断请求分配一个IRQ number!这样经过irq domain知道GPIO的中断是连接在89这个管脚，它不必告诉告诉其他人这个信息，当中断发生后，他只需要上报IRQ number即可。CPU便知道是GPIO1发生了中断。这里我们先列出API：向系统注册一个irq domainirq_domain_add_linearirq_domain_add_treeirq_domain_add_nomap这里设定了irq_domain中的映射关系的类型。在irq domain中建立一个映射关系irq_create_mappingirq_create_direct_mappingirq_create_strict_mappingsirq_create_of_mapping分别对应的解释为：建立HW interrupt ID和IRQ number的映射关系为一组HW interrupt ID建立映射关系给no map那种类型的interrupt controller使用的利用device tree进行映射关系的建立通常，一个普通设备的device tree node已经描述了足够的中断信息，在这种情况下，该设备的驱动在初始化的时候可以调用irq_of_parse_and_map这个接口函数进行该device node中和中断相关的内容1234567unsigned int irq_of_parse_and_map(struct device_node *dev, int index) &#123; struct of_phandle_args oirq; if (of_irq_parse_one(dev, index, &amp;oirq))//分析device node中的interrupt相关属性 return 0; return irq_create_of_mapping(&amp;oirq);//创建映射，并返回对应的IRQ number &#125;GIC注册流程不过很遗憾我们的GIC的驱动程序并没有上述说明的函数来建立映射，接着我们来看看gic_init_bases中如何进行建立映射的步骤。1234567891011121314151617181920212223//这里我们简化一下代码只列出我们关心的流程代码void __init gic_init_bases(unsigned int gic_nr, int irq_start, void __iomem *dist_base, void __iomem *cpu_base, u32 percpu_offset, struct device_node *node)&#123; if(ndoe)&#123; gic-&gt;domain = irq_domain_add_linear(node, gic_irqs, &amp;gic_irq_domain_hierarchy_ops, gic); &#125;else&#123; gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base, hwirq_base, &amp;gic_irq_domain_ops, gic); &#125;#ifdef CONFIG_SMP set_smp_cross_call(gic_raise_softirq); register_cpu_notifier(&amp;gic_cpu_notifier);#endif set_handle_irq(gic_handle_irq); &#125;`这里主要做了两件事irq_domain注册到系统。提供上级使用的irq_handle函数.作为一个interrupt controller，除了注册自己管理的irq_domain，还需要提供给上级使用的irq_handler。作为second GIC，需要调用irq_set_chained_handler注册irq_handler到root GIC中；作为root GIC，上级是CPU，调用set_handle_irq注册到平台的irq处理接口。19行的功能，当CPU发生了中断最先调用的就是root GIC的 gic_handle_irq，然后在此函数中进行gic的irq domain处理。然后：我们注册irq_domain时用到了一个ops:12345678struct irq_domain_ops &#123; int (*match)(struct irq_domain *d, struct device_node *node); int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); void (*unmap)(struct irq_domain *d, unsigned int virq); int (*xlate)(struct irq_domain *d, struct device_node *node, const u32 *intspec, unsigned int intsize, unsigned long *out_hwirq, unsigned int *out_type); &#125;;xlate 是负责翻译的回调函数，在dts文件中，各个设备通过一些属性，例如interrupts和interrupt-parent来提供中断信息给kernel和驱动，而xlate函数就是将指定的设备上若干个中断属性翻译成hwirq和trigger类型，比如对于#interrupt-cells = &lt;3&gt;;的中断控制器来说，描述该域中的一个interrupt需要三个cell来表示，那么这三个cell就是通过xlate来解析的。match用来判断interrupt controller是否和一个irq domain匹配的，如果是就返回1。实际上内核中提供了默认的匹配函数，就是通过of node来进行匹配的.map 和 unmap 是映射和解除映射操作。我们暂时不分析这些函数具体有什么作用，我们回到主代码发现了：irq_of_parse_and_map ，也就是为irq domain建立映射关系的函数，我们解析一下这个函数具体做了什么操作，虽然我们主GIC不会做任何操作。我们还是看一眼创建映射关心代码的流程，这里我们不关注细节只看看调用流程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788unsigned int irq_of_parse_and_map(struct device_node *dev, int index) &#123; struct of_phandle_args oirq; if (of_irq_parse_one(dev, index, &amp;oirq) //分析device node中的interrupt相关属性 return 0; return irq_create_of_mapping(&amp;oirq);//创建映射 &#125; unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data) &#123; struct irq_domain *domain; irq_hw_number_t hwirq; unsigned int type = IRQ_TYPE_NONE; unsigned int virq; domain = irq_data-&gt;np ? irq_find_host(irq_data-&gt;np) : irq_default_domain; if (!domain) &#123; return 0; &#125; //先找到硬件的ID if (domain-&gt;ops-&gt;xlate == NULL) hwirq = irq_data-&gt;args[0]; else &#123; if (domain-&gt;ops-&gt;xlate(domain, irq_data-&gt;np, irq_data-&gt;args, irq_data-&gt;args_count, &amp;hwirq, &amp;type)) return 0; &#125; /* Create mapping */ virq = irq_create_mapping(domain, hwirq); if (!virq) return virq; /* Set type if specified and different than the current one */ if (type != IRQ_TYPE_NONE &amp;&amp; type != irq_get_trigger_type(virq)) irq_set_irq_type(virq, type); return virq; &#125; unsigned int irq_create_mapping(struct irq_domain *domain, irq_hw_number_t hwirq) &#123; unsigned int hint; int virq; virq = irq_find_mapping(domain, hwirq); //如果映射已经存在，那么不需要映射，直接返回 if (virq) &#123; return virq; &#125; hint = hwirq % nr_irqs;//分配一个IRQ 描述符以及对应的irq number if (hint == 0) hint++; virq = irq_alloc_desc_from(hint, of_node_to_nid(domain-&gt;of_node)); if (virq &lt;= 0) virq = irq_alloc_desc_from(1, of_node_to_nid(domain-&gt;of_node)); if (virq &lt;= 0) &#123; pr_debug("-&gt; virq allocation failed\n"); return 0; &#125; if (irq_domain_associate(domain, virq, hwirq)) &#123;//建立mapping irq_free_desc(virq); return 0; &#125; return virq; &#125; int irq_domain_associate(struct irq_domain *domain, unsigned int virq, irq_hw_number_t hwirq) &#123; struct irq_data *irq_data = irq_get_irq_data(virq); int ret; mutex_lock(&amp;irq_domain_mutex); irq_data-&gt;hwirq = hwirq; irq_data-&gt;domain = domain; if (domain-&gt;ops-&gt;map) &#123; ret = domain-&gt;ops-&gt;map(domain, virq, hwirq);//调用irq domain的map callback函数 &#125; if (hwirq &lt; domain-&gt;revmap_size) &#123; domain-&gt;linear_revmap[hwirq] = virq;//填写线性映射lookup table的数据 &#125; else &#123; mutex_lock(&amp;revmap_trees_mutex); radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);//向radix tree插入一个node mutex_unlock(&amp;revmap_trees_mutex); &#125; mutex_unlock(&amp;irq_domain_mutex); irq_clear_status_flags(virq, IRQ_NOREQUEST); //该IRQ已经可以申请了，因此clear相关flag return 0; &#125;这里我们就看出了xlate 和map的 重要性。于是呼我们也看一眼这两个函数怎么实现的？12345678910111213141516171819202122232425262728293031323334353637383940static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)&#123; if (hw &lt; 32) &#123; irq_set_percpu_devid(irq); irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data, handle_percpu_devid_irq, NULL, NULL); set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN); &#125; else &#123; irq_domain_set_info(d, irq, hw, &amp;gic_chip, d-&gt;host_data, handle_fasteoi_irq, NULL, NULL); set_irq_flags(irq, IRQF_VALID | IRQF_PROBE); &#125; return 0;&#125;static int gic_irq_domain_xlate(struct irq_domain *d, struct device_node *controller, const u32 *intspec, unsigned int intsize, unsigned long *out_hwirq, unsigned int *out_type)&#123; unsigned long ret = 0; if (d-&gt;of_node != controller) return -EINVAL; if (intsize &lt; 3) return -EINVAL; /* Get the interrupt number and add 16 to skip over SGIs */ *out_hwirq = intspec[1] + 16; /* For SPIs, we need to add 16 more to get the GIC irq ID number */ if (!intspec[0]) *out_hwirq += 16; *out_type = intspec[2] &amp; IRQ_TYPE_SENSE_MASK; return ret;&#125;好了，我们只是简略的看了一眼，走了个流程，细节还是要对着GIC手册去慢慢填坑，暂时先连接那么多，目的是要把脉络弄清楚，陷入细节还不是现在的目的。接着我们再看看刚才gic设置的中断处理程序：上面已经提到，一个root gic驱动除了提供irq domain以外，还要注册到CPU中断服务程序入口，而这个中断服务的入口就是gic_handle_irq。12345678910111213141516171819202122232425asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)&#123; u32 irqstat, irqnr; struct gic_chip_data *gic = &amp;gic_data[0]; void __iomem *cpu_base = gic_data_cpu_base(gic); do &#123; irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK); irqnr = irqstat &amp; ~0x1c00; if (likely(irqnr &gt; 15 &amp;&amp; irqnr &lt; 1021)) &#123; irqnr = irq_find_mapping(gic-&gt;domain, irqnr); handle_IRQ(irqnr, regs); continue; &#125; if (irqnr &lt; 16) &#123; writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);#ifdef CONFIG_SMP handle_IPI(irqnr, regs);#endif continue; &#125; break; &#125; while (1);&#125;如上所示，中断来的时候会最先调用这个函数，它中会读取GIC寄存器获得hwirq，并且查找对应的irq num，irq_find_mapping是查找irq domain中映射关系的关键函数。然后会调用handle_IRQ来处理对应的irq num，紧接着会调用相应的上层irq handler。这里大致的就将中断控制器GIC流程分析完毕了，下面我们就应该回到GPIO的代码中看看，GPIO是如何把中断和GIC联系起来。这里我认为适当的囫囵吞枣是有必要的，不然容易卡住下不去。我们先一窥究竟，然后在回头，即便好马不吃回头草。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
        <tag>GIC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(二)中断控制器初始化]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio2_irqchip_init.html</url>
    <content type="text"><![CDATA[内核启动流程开始讲gpiolib中的irq相关的内容的内容首先要把启动的流程之前，我们知道存在一共叫做中断控制器的模块。那么我们先看看中断控制器是如何工作的在来看GPIO中的中断与之的联系。首先。我们把启动的调用脉络给列一下，方便后后面分析。我们把启动的流程总结一下：通过设备树找到板配置 machine_desc解析设备树获得struct device_node of_root初始化中断（中断控制器）初始化各种板级设备启动init程序源码跟踪获取板配置的过程不再分析了，这里我们只关注我们板子的配置文件。12345678910//arch/arm/mach-imx/mach-imx6q.cDT_MACHINE_START(IMX6Q, "Freescale i.MX6 Quad/DualLite (Device Tree)") .smp = smp_ops(imx_smp_ops), .map_io = imx6q_map_io, .init_irq = imx6q_init_irq, .init_machine = imx6q_init_machine, .init_late = imx6q_init_late, .dt_compat = imx6q_dt_compat, .reserve = imx6q_reserve,MACHINE_END这里我们去看看imx6q_init_irq具体做了什么事：123456789//arch/arm/mach-imx/mach-imx6q.cstatic void __init imx6q_init_irq(void)&#123; imx_gpc_check_dt(); imx_init_revision_from_anatop(); imx_init_l2cache(); imx_src_init(); irqchip_init();&#125;这里我们关注第4和8行和中断控制器的初始化有关。imx_gpc_check_dtimx_src_init其余的都是芯片本身的初始化，并不需要关心。12345678910111213141516171819//arch/arm/mach-imx/gpc.cstatic void __iomem *gpc_base;OF_DECLARE_2(irqchip, imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);void __init imx_gpc_check_dt(void)&#123; struct device_node *np; np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc"); if (WARN_ON(!np)) return; if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL))) &#123; pr_warn("Outdated DT detected, suspend/resume will NOT work\n"); /* map GPC, so that at least CPUidle and WARs keep working */ gpc_base = of_iomap(np, 0); &#125;&#125;imx_gpc_check_dt做的事比较简单，初始化中断控制器的地址。我们再关注一下宏：OF_DECLARE_212345678910#define OF_DECLARE_2(table, name, compat, fn) \ _OF_DECLARE(table, name, compat, fn, of_init_fn_2)#define _OF_DECLARE(table, name, compat, fn, fn_type) \ static const struct of_device_id __of_table_##name \ __used __section(__##table##_of_table) \ = &#123; .compatible = compat, \ .data = (fn == (fn_type)NULL) ? fn : fn &#125; typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);展开宏可得：1234static const struct of_device_id __of_table_imx_gpc __used __section(__irqchip_of_table) = &#123; .compatible = "fsl,imx6q-gpc", .data = imx_gpc_init &#125;这里我相信这个结构体__of_table_imx_gpc肯定是会用到了，先放一下。我们看看另外的一个我们关注的函数irqchip_init()函数，具体做了什么。12345678910111213//drivers/irqchip/irqchip.cstatic const struct of_device_idirqchip_of_match_end __used __section(__irqchip_of_table_end);extern struct of_device_id __irqchip_of_table[];void __init irqchip_init(void)&#123; of_irq_init(__irqchip_of_table); acpi_irq_init();&#125;果然就用到了，__irqchip_of_table 的section是放到.init.data中，具体可以看一下: arch/arm/kernel/vmlinux.lds这里我们发现了一个问题：在driver/irqchip大量使用IRQCHIP_DECLARE来，为什么imx为什么自己又定义出了一个宏呢？注释中解释了原因，我们不应该使用驱动目录下头文件，所以不得已为之，也说明了这样做不是很好！既然这样我们也顺道看看IRQCHIP_DECLARE，结果发现根本就是一回事！#define IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)1234/* * We cannot use the IRQCHIP_DECLARE macro that lives in * drivers/irqchip, so we&apos;re forced to roll our own. Not very nice. */我们回到函数irqchip_init中调用了of_irq_init根据这个名字of是对设备树的操作，然后参数是irqchip_of_table，这里我们不难猜这个函数的作用。大胆的猜测 函数将加入到irqchip_of_table中的IRQ控制器和设备树进行匹配后初始化对应的控制器。在调用之前我们先来看看设备树中我们定义了那些IRQ控制？好！这个检索的过程我就卖个苦力来对比一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152intc: interrupt-controller@00a01000 &#123; compatible = "arm,cortex-a9-gic"; #interrupt-cells = &lt;3&gt;; interrupt-controller; reg = &lt;0x00a01000 0x1000&gt;, &lt;0x00a00100 0x100&gt;; interrupt-parent = &lt;&amp;intc&gt;; &#125;; gpio1: gpio@0209c000 &#123; compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio"; reg = &lt;0x0209c000 0x4000&gt;; interrupts = &lt;0 66 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0 67 IRQ_TYPE_LEVEL_HIGH&gt;; gpio-controller; #gpio-cells = &lt;2&gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;; &#125;; gpc: gpc@020dc000 &#123; compatible = "fsl,imx6q-gpc"; reg = &lt;0x020dc000 0x4000&gt;; interrupt-controller; #interrupt-cells = &lt;3&gt;; interrupts = &lt;0 89 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0 90 IRQ_TYPE_LEVEL_HIGH&gt;; interrupt-parent = &lt;&amp;intc&gt;; pu-supply = &lt;&amp;reg_pu&gt;; clocks = &lt;&amp;clks IMX6QDL_CLK_GPU3D_CORE&gt;, &lt;&amp;clks IMX6QDL_CLK_GPU3D_SHADER&gt;, &lt;&amp;clks IMX6QDL_CLK_GPU2D_CORE&gt;, &lt;&amp;clks IMX6QDL_CLK_GPU2D_AXI&gt;, &lt;&amp;clks IMX6QDL_CLK_OPENVG_AXI&gt;, &lt;&amp;clks IMX6QDL_CLK_VPU_AXI&gt;; #power-domain-cells = &lt;1&gt;; &#125;; fec: ethernet@02188000 &#123; compatible = "fsl,imx6q-fec"; reg = &lt;0x02188000 0x4000&gt;; interrupts-extended = &lt;&amp;gpc 0 118 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;&amp;gpc 0 119 IRQ_TYPE_LEVEL_HIGH&gt;; clocks = &lt;&amp;clks IMX6QDL_CLK_ENET&gt;, &lt;&amp;clks IMX6QDL_CLK_ENET&gt;, &lt;&amp;clks IMX6QDL_CLK_ENET_REF&gt;; clock-names = "ipg", "ahb", "ptp"; stop-mode = &lt;&amp;gpr 0x34 27&gt;; fsl,wakeup_irq = &lt;0&gt;; status = "disabled"; &#125;;这里统计了一下设备树的interrupt控制器三类:gic “arm,cortex-a9-gic”gpio”fsl,imx6q-gpio”, “fsl,imx35-gpio”gpc”fsl,imx6q-gpc”;代码中：irq-gic.c:1037:IRQCHIP_DECLARE(cortex_a9_gic, “arm,cortex-a9-gic”, gic_of_init);gpc.c:571:OF_DECLARE_2(irqchip, imx_gpc, “fsl,imx6q-gpc”, imx_gpc_init);这里 gpc接在gic上，从设备树中的interrupt-parent可以看出这里我们就记住了需要初始化的只有GIC和GPC,这里我们去看看of_irq_init来验证我们的想法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//drivers/of/irq.cvoid __init of_irq_init(const struct of_device_id *matches)&#123; struct device_node *np, *parent = NULL; struct intc_desc *desc, *temp_desc; struct list_head intc_desc_list, intc_parent_list; INIT_LIST_HEAD(&amp;intc_desc_list); INIT_LIST_HEAD(&amp;intc_parent_list); for_each_matching_node(np, matches) &#123; if (!of_find_property(np, "interrupt-controller", NULL) || !of_device_is_available(np)) continue; /* * Here, we allocate and populate an intc_desc with the node * pointer, interrupt-parent device_node etc. */ desc = kzalloc(sizeof(*desc), GFP_KERNEL); if (WARN_ON(!desc)) goto err; desc-&gt;dev = np; desc-&gt;interrupt_parent = of_irq_find_parent(np); if (desc-&gt;interrupt_parent == np) desc-&gt;interrupt_parent = NULL; list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list); &#125; /* * The root irq controller is the one without an interrupt-parent. * That one goes first, followed by the controllers that reference it, * followed by the ones that reference the 2nd level controllers, etc. */ while (!list_empty(&amp;intc_desc_list)) &#123; /* * Process all controllers with the current 'parent'. * First pass will be looking for NULL as the parent. * The assumption is that NULL parent means a root controller. */ list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) &#123; const struct of_device_id *match; int ret; of_irq_init_cb_t irq_init_cb; if (desc-&gt;interrupt_parent != parent) continue; list_del(&amp;desc-&gt;list); match = of_match_node(matches, desc-&gt;dev); if (WARN(!match-&gt;data, "of_irq_init: no init function for %s\n", match-&gt;compatible)) &#123; kfree(desc); continue; &#125; pr_debug("of_irq_init: init %s @ %p, parent %p\n", match-&gt;compatible, desc-&gt;dev, desc-&gt;interrupt_parent); irq_init_cb = (of_irq_init_cb_t)match-&gt;data; ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent); if (ret) &#123; kfree(desc); continue; &#125; /* * This one is now set up; add it to the parent list so * its children can get processed in a subsequent pass. */ list_add_tail(&amp;desc-&gt;list, &amp;intc_parent_list); &#125; /* Get the next pending parent that might have children */ desc = list_first_entry_or_null(&amp;intc_parent_list, typeof(*desc), list); if (!desc) &#123; pr_err("of_irq_init: children remain, but no parents\n"); break; &#125; list_del(&amp;desc-&gt;list); parent = desc-&gt;dev; kfree(desc); &#125; list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, list) &#123; list_del(&amp;desc-&gt;list); kfree(desc); &#125;err: list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) &#123; list_del(&amp;desc-&gt;list); kfree(desc); &#125;&#125;这个代码比较长，逻辑还是比较简单的。从设备树中找到所用的中断控制器匹配__irqchip_of_table中的设备（也就是中断控制器），依次从父设备-子设备的顺序进行初始化。中断控制器介绍于是下面我们就看看GIC和GPC是做什么用的?首先需要介绍一下GIC和GPCGIC : General Interrupt Control这个玩意儿是ARM做的通用的中断控制器，就不详细描述它了，可以上网搜搜GIC V2的资料。简单的说：ARM CPU 对外的连接只有 2 个中断，一个是 IRQ ，一个是 FIQ ，相对应的处理模式分别是一般中断（ IRQ ）处理模式和快速中断（ FIQ ）处理模式。所以 GIC 最后要把中断汇集成 2 条线，与 CPU 对接。GPC： General Power Control这里我们很难想象通用电源控制器和中断有什么关系？这里GPC中包含了一个中断控制器的子模块，从结构图中我们看出主要是用来做 通知CCM（时钟控制模块）/CPU用的。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux4.x之Gpio分析(一)Gpiolib库]]></title>
    <url>%2Flinux%2Fsrc%2Flinux4x_gpio1_gpiolib.html</url>
    <content type="text"><![CDATA[下面的内容均在imx6平台上举例，这一次分析希望将整个GPIO子系统的所有细节整理清晰。第一篇从gpiolib入手，后面的边分析边写.开始之前给自己提几个问题驱动开发中的GPIO API 究竟是怎么实现的？GPIO的中断又是怎么实现的？GPIO号和IRQ的号码怎么映射的？1.芯片定义我们在驱动程序中会用到gpio_request(x),这里的x便是gpio的编号，而GPIO通常会分组，在原理图经常会看见GPIO2_5类似的标识，通常我们先会翻阅一下datesheet来了解一下这块芯片的定义是如何。在imx6芯片中的将GPIO分成了若干组，每组为32个管脚。我们简单的阅读一下芯片手册：IMX6的gpio控制结构:我们的芯片会引出一堆引脚，而在芯片的内部会集成很多control，（我们称这些control为block）其中的引脚可以功能复用，比如说A1 A2脚支持I2C功能也支持GPIO功能，我可以将I2C1_control的管脚连接过来，或者将GPIO1_1的管脚连接上来，这个就是IOMUX的作用：提供PIN不同的功能切换。所以我们在使用芯片之前会先根据主板的配置先将各个管脚配置为正确的功能的Pin.寄存器：Data register (GPIO_DR)GPIO direction register (GPIO_GDIR)Pad sample register (GPIO_PSR)Interrupt control registers (GPIO_ICR1, GPIO_ICR2)Interrupt mask register (GPIO_IMR)Interrupt status register (GPIO_ISR)GPIO edge select register (GPIO_EDEG_SEL )简单介绍一下DR 当作为输出时控制管脚高低电平GDIR 控制管脚作为输入还是输出PSR 作为输出时获取管脚的高低电平ICR1 ICR2 是配置中断的触发方式 高/低电平触发 上升/下降沿 触发IMR 中断屏蔽寄存器ISR 中断状态寄存器 哪个管脚触发了中断EDEG_SEL 边缘触发模式(上/下沿都触发)GPIO有7组,每组32个，最后一组14个2.设备树我们了解了一下内部的结构，接着就要开始看代码了，在看代码之前看看设备树，才能定位到代码在哪里。这里只列出一个gpio-controller123456789101112131415161718 aliases &#123; ethernet0 = &amp;fec; can0 = &amp;can1; can1 = &amp;can2; gpio0 = &amp;gpio1; gpio1 = &amp;gpio2; ..... &#125;gpio1: gpio@0209c000 &#123; compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio"; reg = &lt;0x0209c000 0x4000&gt;; interrupts = &lt;0 66 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0 67 IRQ_TYPE_LEVEL_HIGH&gt;; gpio-controller; #gpio-cells = &lt;2&gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;;&#125;;我们通过compatible的值可以找到对应的驱动代码路径 driver/gpio/gpio-mxc.cGPIO1控制寄存器的地址是0x0209c000，长度0x4000，使用66和67号中断。这里疑惑的地方是为什只用了两个中断号，而不是32个？我们知道一个GPIO控制是通过总线连接到CPU，中断连接到中断控制器(GIC),那么中断线太多就以为着GIC的数量也需要增加，如果GPIO控制器内部进行判断是哪个管脚触发的那么就可以避免GIC的数量。而我们的芯片内部只有一个GIC.IRQSourceInterrupt Description32IOMUXCGeneral Purpose Register 1 from IOMUXC. Used to notify cores on exception condition whileboot.33DAPDebug Access Port interrupt request98GPIO1Combined interrupt indication for GPIO1 signals 0 - 15.99GPIO1Combined interrupt indication for GPIO1 signals 16 - 31.这里中断号的来源是芯片手册，因为GIC的连接是这样的，这里0-31是内部使用，32开始用作外设。驱动中用编号0直接开始编号。地址参考寄存器MAPAbsoluteaddressRegister name Widt (bits)AccessReset value209_C000GPIO data register (GPIO1_DR)32R/W0000_0000h209_C004GPIO direction register (GPIO1_GDIR)32R/W0000_0000h209_C008GPIO pad status register (GPIO1_PSR)32R0000_0000h209_C00CGPIO interrupt configuration register1 (GPIO1_ICR1)32R/W0000_0000h209_C010GPIO interrupt configuration register2 (GPIO1_ICR2)32R/W0000_0000h209_C014GPIO interrupt mask register (GPIO1_IMR)32R/W0000_0000h209_C018GPIO interrupt status register (GPIO1_ISR)32w1c0000_0000h209_C018GPIO interrupt status register (GPIO1_ISR)32w1c0000_0000h209_C01CGPIO edge select register (GPIO1_EDGE_SEL)32R/W0000_0000h20A_0000GPIO data register (GPIO2_DR)32R/W0000_0000h3.代码从设备树中我们知道了代码的路径位置，我们先看看gpio这个目录的Makefile：12345678910111213obj-$(CONFIG_GPIO_DEVRES) += devres.oobj-$(CONFIG_GPIOLIB) += gpiolib.oobj-$(CONFIG_GPIOLIB) += gpiolib-legacy.oobj-$(CONFIG_OF_GPIO) += gpiolib-of.oobj-$(CONFIG_GPIO_SYSFS) += gpiolib-sysfs.oobj-$(CONFIG_GPIO_ACPI) += gpiolib-acpi.o# Device drivers. Generally keep list sorted alphabeticallyobj-$(CONFIG_GPIO_GENERIC) += gpio-generic.oobj-$(CONFIG_GPIO_74X164) += gpio-74x164.o.....(省略一些无关紧要的内容)obj-$(CONFIG_GPIO_MXC) += gpio-mxc.o这里分三类：gpiolib的代码gpio-generic代码gpio特定平台的代码代码的结构：GPIOLIB 调用 GPIO_GENRIC 调用 GPIO_MXC接着我们开始分析代码：代码主要讲了初始化GPIO控制器和GPIO的中断控制器，这里先分析gpio控制器和如何与gpiolib联系1234567891011121314151617181920212223242526272829303132static const struct of_device_id mxc_gpio_dt_ids[] = &#123; &#123; .compatible = "fsl,imx1-gpio", .data = &amp;mxc_gpio_devtype[IMX1_GPIO], &#125;, &#123; .compatible = "fsl,imx21-gpio", .data = &amp;mxc_gpio_devtype[IMX21_GPIO], &#125;, &#123; .compatible = "fsl,imx31-gpio", .data = &amp;mxc_gpio_devtype[IMX31_GPIO], &#125;, &#123; .compatible = "fsl,imx35-gpio", .data = &amp;mxc_gpio_devtype[IMX35_GPIO], &#125;, &#123; /* sentinel */ &#125;&#125;;enum mxc_gpio_hwtype &#123; IMX1_GPIO, /* runs on i.mx1 */ IMX21_GPIO, /* runs on i.mx21 and i.mx27 */ IMX31_GPIO, /* runs on i.mx31 */ IMX35_GPIO, /* runs on all other i.mx */&#125;;static struct platform_device_id mxc_gpio_devtype[] = &#123; &#123; .name = "imx1-gpio", .driver_data = IMX1_GPIO, &#125;, &#123; .name = "imx21-gpio", .driver_data = IMX21_GPIO, &#125;, &#123; .name = "imx31-gpio", .driver_data = IMX31_GPIO, &#125;, &#123; .name = "imx35-gpio", .driver_data = IMX35_GPIO, &#125;, &#123; /* sentinel */ &#125;&#125;;这里是为了兼容性考虑，这个分支感觉写的很有水准以后可以借鉴一下。接着来看看porbe 的流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static int mxc_gpio_probe(struct platform_device *pdev)&#123; struct device_node *np = pdev-&gt;dev.of_node; struct mxc_gpio_port *port; struct resource *iores; int irq_base; int err; mxc_gpio_get_hw(pdev); //1 port = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*port), GFP_KERNEL); if (!port) return -ENOMEM; //从设备树中获取寄存器地址，IOREMAP就是将物理地址转化称虚拟地址 iores = platform_get_resource(pdev, IORESOURCE_MEM, 0); port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores); if (IS_ERR(port-&gt;base)) return PTR_ERR(port-&gt;base); //从设备树中获取中断号,上面也解释了为啥是2个。 port-&gt;irq_high = platform_get_irq(pdev, 1); port-&gt;irq = platform_get_irq(pdev, 0); if (port-&gt;irq &lt; 0) return port-&gt;irq; //关中断，清理中断触发状态。 //中断屏蔽位的作用就是是否要关心这个中断 //中断状态位的作用就是，当中断发生了，我们需要查一下是谁发生了中断。 /* disable the interrupt and clear the status */ writel(0, port-&gt;base + GPIO_IMR); writel(~0, port-&gt;base + GPIO_ISR); if (mxc_gpio_hwtype == IMX21_GPIO) &#123; /* * Setup one handler for all GPIO interrupts. Actually setting * the handler is needed only once, but doing it for every port * is more robust and easier. */ irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler); &#125; else &#123; /* setup one handler for each entry */ //2 //函数修改父中断的流控函数，当发生中断，中断控制器会去调用这个函数 irq_set_chained_handler(port-&gt;irq, mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq, port); if (port-&gt;irq_high &gt; 0) &#123; /* setup handler for GPIO 16 to 31 */ irq_set_chained_handler(port-&gt;irq_high, mx3_gpio_irq_handler); irq_set_handler_data(port-&gt;irq_high, port); &#125; &#125; //3 err = bgpio_init(&amp;port-&gt;bgc, &amp;pdev-&gt;dev, 4, port-&gt;base + GPIO_PSR, port-&gt;base + GPIO_DR, NULL, port-&gt;base + GPIO_GDIR, NULL, 0); if (err) goto out_bgio;//设置gpio和软件中断号映射的关系 port-&gt;bgc.gc.to_irq = mxc_gpio_to_irq;//设置gpio的编号基数 port-&gt;bgc.gc.base = (pdev-&gt;id &lt; 0) ? of_alias_get_id(np, "gpio") * 32 : pdev-&gt;id * 32;//将GPIO控制器计入到gpiolib驱动的链表中，也就是之后我们可以gpio_direction去操作io了 err = gpiochip_add(&amp;port-&gt;bgc.gc); if (err) goto out_bgpio_remove; irq_base = irq_alloc_descs(-1, 0, 32, numa_node_id()); if (irq_base &lt; 0) &#123; err = irq_base; goto out_gpiochip_remove; &#125;//向中断控制器注册并创建映射关系 port-&gt;domain = irq_domain_add_legacy(np, 32, irq_base, 0, &amp;irq_domain_simple_ops, NULL); if (!port-&gt;domain) &#123; err = -ENODEV; goto out_irqdesc_free; &#125;//初始化gpio中断控制器 /* gpio-mxc can be a generic irq chip */ mxc_gpio_init_gc(port, irq_base); list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports); return 0;out_irqdesc_free: irq_free_descs(irq_base, 32);out_gpiochip_remove: gpiochip_remove(&amp;port-&gt;bgc.gc);out_bgpio_remove: bgpio_remove(&amp;port-&gt;bgc);out_bgio: dev_info(&amp;pdev-&gt;dev, "%s failed with errno %d\n", __func__, err); return err;&#125;先看 mxc_gpio_get_hw吧，其实也就是初始化了两个全局变量：1234567891011121314151617181920212223242526272829303132static enum mxc_gpio_hwtype mxc_gpio_hwtype;static struct mxc_gpio_hwdata *mxc_gpio_hwdata;static void mxc_gpio_get_hw(struct platform_device *pdev)&#123; const struct of_device_id *of_id = of_match_device(mxc_gpio_dt_ids, &amp;pdev-&gt;dev); enum mxc_gpio_hwtype hwtype; if (of_id) pdev-&gt;id_entry = of_id-&gt;data; hwtype = pdev-&gt;id_entry-&gt;driver_data; if (mxc_gpio_hwtype) &#123; /* * The driver works with a reasonable presupposition, * that is all gpio ports must be the same type when * running on one soc. */ BUG_ON(mxc_gpio_hwtype != hwtype); return; &#125; if (hwtype == IMX35_GPIO) mxc_gpio_hwdata = &amp;imx35_gpio_hwdata; else if (hwtype == IMX31_GPIO) mxc_gpio_hwdata = &amp;imx31_gpio_hwdata; else mxc_gpio_hwdata = &amp;imx1_imx21_gpio_hwdata; mxc_gpio_hwtype = hwtype;&#125;看一眼这两个变量是何方神圣：12345678910111213141516171819202122232425262728293031323334353637enum mxc_gpio_hwtype &#123; IMX1_GPIO, /* runs on i.mx1 */ IMX21_GPIO, /* runs on i.mx21 and i.mx27 */ IMX31_GPIO, /* runs on i.mx31 */ IMX35_GPIO, /* runs on all other i.mx */&#125;;struct mxc_gpio_hwdata &#123; unsigned dr_reg; unsigned gdir_reg; unsigned psr_reg; unsigned icr1_reg; unsigned icr2_reg; unsigned imr_reg; unsigned isr_reg; int edge_sel_reg; unsigned low_level; unsigned high_level; unsigned rise_edge; unsigned fall_edge;&#125;;static struct mxc_gpio_hwdata imx35_gpio_hwdata = &#123; .dr_reg = 0x00,//写如内容驱动IO .gdir_reg = 0x04,//控制IO的方向 input output .psr_reg = 0x08,//读IO口电平 .icr1_reg = 0x0c,//中断1 0-15 .icr2_reg = 0x10,//中断2 16-31 控制电平触发方式 00 low 01 hig 10 rise 11 fall .imr_reg = 0x14,//中断屏蔽位 .isr_reg = 0x18,//中断状态寄存器，中断是否发生 .edge_sel_reg = 0x1c,//覆盖ICR寄存器，选择EDGE方式（上升沿下降沿均触发这个意思把？） .low_level = 0x00, .high_level = 0x01, .rise_edge = 0x02, .fall_edge = 0x03,&#125;;原来不就是记录一下控制寄存器是 imx35，和对应的寄存器的偏移位置而已。我们先看port这个变量的结构，这里就是为了初始化这个结构体。12345678910111213141516171819202122232425262728293031323334353637383940414243struct mxc_gpio_port &#123; struct list_head node; void __iomem *base; //gpio寄存器基地址 int irq; //gpio中断号0-15用这个 int irq_high; //gpio中断号16-31用这个 struct irq_domain *domain; //irq_domain放到中断里面再介绍吧 struct bgpio_chip bgc;//这个结构存放了寄存器的信息主要在gpio-genirc中用 u32 both_edges;//双边沿触发的标识位，主要是为了兼容不带边双沿触发寄存器的芯片&#125;;struct bgpio_chip &#123; struct gpio_chip gc; unsigned long (*read_reg)(void __iomem *reg); void (*write_reg)(void __iomem *reg, unsigned long data); void __iomem *reg_dat; void __iomem *reg_set; void __iomem *reg_clr; void __iomem *reg_dir; /* Number of bits (GPIOs): &lt;register width&gt; * 8. */ int bits; /* * Some GPIO controllers work with the big-endian bits notation, * e.g. in a 8-bits register, GPIO7 is the least significant bit. */ unsigned long (*pin2mask)(struct bgpio_chip *bgc, unsigned int pin); /* * Used to lock bgpio_chip-&gt;data. Also, this is needed to keep * shadowed and real data registers writes together. */ spinlock_t lock; /* Shadowed data register to clear/set bits safely. */ unsigned long data; /* Shadowed direction registers to clear/set direction safely. */ unsigned long dir;&#125;;bgpio_chip 我们可以在代码bgpio_init那里读代码分析它，暂时先不看了。好！我们接着看probe中注释2代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)&#123; u32 irq_stat; struct mxc_gpio_port *port = irq_get_handler_data(irq); struct irq_chip *chip = irq_get_chip(irq); chained_irq_enter(chip, desc); //读中断状态寄存器确定哪个管脚发生中断，并且如何中断屏蔽位为0，忽略这个中断 irq_stat = readl(port-&gt;base + GPIO_ISR) &amp; readl(port-&gt;base + GPIO_IMR); //调用中断处理程序 mxc_gpio_irq_handler(port, irq_stat); chained_irq_exit(chip, desc);&#125;/* handle 32 interrupts in one status register */static void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)&#123; while (irq_stat != 0) &#123; //fls或去最高有效位（从低位往左数最后的有效bit位） //这里就是得到哪个管脚触发的中断，一一处理，而且优先级就是按照这个规则来了。 int irqoffset = fls(irq_stat) - 1; //这里的做法是为了让没有双边沿触发的芯片，用轮流高低电平触发的方式解决。 //imx6芯片忽略就好，也看了半天才看清楚原来是这样。 if (port-&gt;both_edges &amp; (1 &lt;&lt; irqoffset)) mxc_flip_edge(port, irqoffset); //irq_find_mapping 这个再说吧，先记一下 generic_handle_irq(irq_find_mapping(port-&gt;domain, irqoffset)); irq_stat &amp;= ~(1 &lt;&lt; irqoffset); &#125;&#125;static void mxc_flip_edge(struct mxc_gpio_port *port, u32 gpio)&#123; void __iomem *reg = port-&gt;base; u32 bit, val; int edge; /*0-15 ICR1 16-31 IRC2*/ reg += GPIO_ICR1 + ((gpio &amp; 0x10) &gt;&gt; 2); /* lower or upper register */ bit = gpio &amp; 0xf; val = readl(reg); edge = (val &gt;&gt; (bit &lt;&lt; 1)) &amp; 3; val &amp;= ~(0x3 &lt;&lt; (bit &lt;&lt; 1)); if (edge == GPIO_INT_HIGH_LEV) &#123; edge = GPIO_INT_LOW_LEV; pr_debug("mxc: switch GPIO %d to low trigger\n", gpio); &#125; else if (edge == GPIO_INT_LOW_LEV) &#123; edge = GPIO_INT_HIGH_LEV; pr_debug("mxc: switch GPIO %d to high trigger\n", gpio); &#125; else &#123; pr_err("mxc: invalid configuration for GPIO %d: %x\n", gpio, edge); return; &#125; writel(val | (edge &lt;&lt; (bit &lt;&lt; 1)), reg);&#125;//中断处理程序看完了，我们接着看注释3123456789101112131415161718192021222324252627282930313233343536373839404142 err = bgpio_init(&amp;port-&gt;bgc, &amp;pdev-&gt;dev, 4, port-&gt;base + GPIO_PSR, port-&gt;base + GPIO_DR, NULL, port-&gt;base + GPIO_GDIR, NULL, 0); int bgpio_init(struct bgpio_chip *bgc, struct device *dev, unsigned long sz, void __iomem *dat, void __iomem *set, void __iomem *clr, void __iomem *dirout, void __iomem *dirin, unsigned long flags)&#123; int ret; if (!is_power_of_2(sz)) return -EINVAL; bgc-&gt;bits = sz * 8; //寄存器位数 4*8=32 spin_lock_init(&amp;bgc-&gt;lock); bgc-&gt;gc.dev = dev; bgc-&gt;gc.label = dev_name(dev); bgc-&gt;gc.base = -1; bgc-&gt;gc.ngpio = bgc-&gt;bits; //gpio数量 bgc-&gt;gc.request = bgpio_request; //1 ret = bgpio_setup_io(bgc, dat, set, clr); //2 ret = bgpio_setup_accessors(dev, bgc, flags &amp; BGPIOF_BIG_ENDIAN, flags &amp; BGPIOF_BIG_ENDIAN_BYTE_ORDER); //3 ret = bgpio_setup_direction(bgc, dirout, dirin); bgc-&gt;data = bgc-&gt;read_reg(bgc-&gt;reg_dat); if (bgc-&gt;gc.set == bgpio_set_set &amp;&amp; !(flags &amp; BGPIOF_UNREADABLE_REG_SET)) bgc-&gt;data = bgc-&gt;read_reg(bgc-&gt;reg_set); if (bgc-&gt;reg_dir &amp;&amp; !(flags &amp; BGPIOF_UNREADABLE_REG_DIR)) bgc-&gt;dir = bgc-&gt;read_reg(bgc-&gt;reg_dir); return ret;我们这里主要对gc这个参数进行了初始化，这个结构gpio控制器，最重要的参io的数量,对应的操作函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct gpio_chip &#123; const char *label; struct device *dev; struct module *owner; struct list_head list; int (*request)(struct gpio_chip *chip, unsigned offset); void (*free)(struct gpio_chip *chip, unsigned offset); int (*get_direction)(struct gpio_chip *chip, unsigned offset); int (*direction_input)(struct gpio_chip *chip, unsigned offset); int (*direction_output)(struct gpio_chip *chip, unsigned offset, int value); int (*get)(struct gpio_chip *chip, unsigned offset); void (*set)(struct gpio_chip *chip, unsigned offset, int value); void (*set_multiple)(struct gpio_chip *chip, unsigned long *mask, unsigned long *bits); int (*set_debounce)(struct gpio_chip *chip, unsigned offset, unsigned debounce); int (*get_direction)(struct gpio_chip *chip, unsigned offset); int (*direction_input)(struct gpio_chip *chip, unsigned offset); int (*direction_output)(struct gpio_chip *chip, unsigned offset, int value); int (*get)(struct gpio_chip *chip, unsigned offset); void (*set)(struct gpio_chip *chip, unsigned offset, int value); void (*set_multiple)(struct gpio_chip *chip, unsigned long *mask, unsigned long *bits); int (*set_debounce)(struct gpio_chip *chip, unsigned offset, unsigned debounce); int (*to_irq)(struct gpio_chip *chip, unsigned offset); void (*dbg_show)(struct seq_file *s, struct gpio_chip *chip); int base; u16 ngpio; struct gpio_desc *desc; const char *const *names; bool can_sleep; bool irq_not_threaded; bool exported;&#125;接着我们就看看三个setup函数如何去初始化这些接口.1234567891011121314151617181920212223242526static int bgpio_setup_io(struct bgpio_chip *bgc, void __iomem *dat, void __iomem *set, void __iomem *clr)&#123; bgc-&gt;reg_dat = dat; if (!bgc-&gt;reg_dat) return -EINVAL; if (set &amp;&amp; clr) &#123; bgc-&gt;reg_set = set; bgc-&gt;reg_clr = clr; bgc-&gt;gc.set = bgpio_set_with_clear; bgc-&gt;gc.set_multiple = bgpio_set_multiple_with_clear; &#125; else if (set &amp;&amp; !clr) &#123; bgc-&gt;reg_set = set; bgc-&gt;gc.set = bgpio_set_set; bgc-&gt;gc.set_multiple = bgpio_set_multiple_set; &#125; else &#123; bgc-&gt;gc.set = bgpio_set; bgc-&gt;gc.set_multiple = bgpio_set_multiple; &#125; bgc-&gt;gc.get = bgpio_get; return 0;&#125;配置了get和set函数，这里我们没有clr寄存器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int bgpio_setup_accessors(struct device *dev, struct bgpio_chip *bgc, bool bit_be, bool byte_be)&#123; switch (bgc-&gt;bits) &#123; case 8: bgc-&gt;read_reg = bgpio_read8; bgc-&gt;write_reg = bgpio_write8; break; case 16: if (byte_be) &#123; bgc-&gt;read_reg = bgpio_read16be; bgc-&gt;write_reg = bgpio_write16be; &#125; else &#123; bgc-&gt;read_reg = bgpio_read16; bgc-&gt;write_reg = bgpio_write16; &#125; break; case 32: if (byte_be) &#123; bgc-&gt;read_reg = bgpio_read32be; bgc-&gt;write_reg = bgpio_write32be; &#125; else &#123; bgc-&gt;read_reg = bgpio_read32; bgc-&gt;write_reg = bgpio_write32; &#125; break;#if BITS_PER_LONG &gt;= 64 case 64: if (byte_be) &#123; dev_err(dev, "64 bit big endian byte order unsupported\n"); return -EINVAL; &#125; else &#123; bgc-&gt;read_reg = bgpio_read64; bgc-&gt;write_reg = bgpio_write64; &#125; break;#endif /* BITS_PER_LONG &gt;= 64 */ default: dev_err(dev, "unsupported data width %u bits\n", bgc-&gt;bits); return -EINVAL; &#125; bgc-&gt;pin2mask = bit_be ? bgpio_pin2mask_be : bgpio_pin2mask; return 0;&#125;这里配置寄存器读写大小端和位数的问题，像bgpio_get等函数都是会调用对应寄存器读，这里很简单的流程就不在追下去了，接着是最后一个setup123456789101112131415161718192021static int bgpio_setup_direction(struct bgpio_chip *bgc, void __iomem *dirout, void __iomem *dirin)&#123; if (dirout &amp;&amp; dirin) &#123; return -EINVAL; &#125; else if (dirout) &#123; bgc-&gt;reg_dir = dirout; bgc-&gt;gc.direction_output = bgpio_dir_out; bgc-&gt;gc.direction_input = bgpio_dir_in; &#125; else if (dirin) &#123; bgc-&gt;reg_dir = dirin; bgc-&gt;gc.direction_output = bgpio_dir_out_inv; bgc-&gt;gc.direction_input = bgpio_dir_in_inv; &#125; else &#123; bgc-&gt;gc.direction_output = bgpio_simple_dir_out; bgc-&gt;gc.direction_input = bgpio_simple_dir_in; &#125; return 0;&#125;这里我们只有一个dirout的寄存器，作为输出只用将哪一个寄存器是能即可。这里init就分析完了，如何或去电平高低,设置io口方向，和输出电平高低的功能都OK了。最后probe 中一共最关键的函数gpiochip_add 我们再看看如何将GPIO控制器和gpiolib关联。关于中断我们放到下一张讲解。接着我们看一下gpiochip_add123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int gpiochip_add(struct gpio_chip *chip)&#123; unsigned long flags; int status = 0; unsigned id; int base = chip-&gt;base; struct gpio_desc *descs; descs = kcalloc(chip-&gt;ngpio, sizeof(descs[0]), GFP_KERNEL); if (!descs) return -ENOMEM; spin_lock_irqsave(&amp;gpio_lock, flags); if (base &lt; 0) &#123; base = gpiochip_find_base(chip-&gt;ngpio); if (base &lt; 0) &#123; status = base; spin_unlock_irqrestore(&amp;gpio_lock, flags); goto err_free_descs; &#125; chip-&gt;base = base; &#125; status = gpiochip_add_to_list(chip); if (status) &#123; spin_unlock_irqrestore(&amp;gpio_lock, flags); goto err_free_descs; &#125; for (id = 0; id &lt; chip-&gt;ngpio; id++) &#123; struct gpio_desc *desc = &amp;descs[id]; desc-&gt;chip = chip; /* REVISIT: most hardware initializes GPIOs as inputs (often * with pullups enabled) so power usage is minimized. Linux * code should set the gpio direction first thing; but until * it does, and in case chip-&gt;get_direction is not set, we may * expose the wrong direction in sysfs. */ desc-&gt;flags = !chip-&gt;direction_input ? (1 &lt;&lt; FLAG_IS_OUT) : 0; &#125; chip-&gt;desc = descs; spin_unlock_irqrestore(&amp;gpio_lock, flags);#ifdef CONFIG_PINCTRL INIT_LIST_HEAD(&amp;chip-&gt;pin_ranges);#endif of_gpiochip_add(chip); acpi_gpiochip_add(chip); status = gpiochip_export(chip); if (status) goto err_remove_chip; pr_debug("%s: registered GPIOs %d to %d on device: %s\n", __func__, chip-&gt;base, chip-&gt;base + chip-&gt;ngpio - 1, chip-&gt;label ? : "generic"); return 0;这里最关键的就是将控制器加入到链表中，然后初始化了各个desc也就是管脚的信息gpiochip_add_to_list(chip);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct gpio_desc *gpio_to_desc(unsigned gpio)&#123; struct gpio_chip *chip; unsigned long flags; spin_lock_irqsave(&amp;gpio_lock, flags); list_for_each_entry(chip, &amp;gpio_chips, list) &#123; if (chip-&gt;base &lt;= gpio &amp;&amp; chip-&gt;base + chip-&gt;ngpio &gt; gpio) &#123; spin_unlock_irqrestore(&amp;gpio_lock, flags); return &amp;chip-&gt;desc[gpio - chip-&gt;base]; &#125; &#125; spin_unlock_irqrestore(&amp;gpio_lock, flags); if (!gpio_is_valid(gpio)) WARN(1, "invalid GPIO %d\n", gpio); return NULL;&#125;static bool _gpiod_get_raw_value(const struct gpio_desc *desc)&#123; struct gpio_chip *chip; bool value; int offset; chip = desc-&gt;chip; offset = gpio_chip_hwgpio(desc); value = chip-&gt;get ? chip-&gt;get(chip, offset) : false; trace_gpio_value(desc_to_gpio(desc), 1, value); return value;&#125;int gpiod_get_value_cansleep(const struct gpio_desc *desc)&#123; int value; might_sleep_if(extra_checks); if (!desc) return 0; value = _gpiod_get_raw_value(desc); if (test_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags)) value = !value; return value;&#125;这里发现gpio库的变化非常大，类似gpio_direction_input的实现都消失了，并不了解为什么?如果我们在驱动中需要获得某个关键的电平：int val =gpiod_get_value_cansleep(gpio_to_desc(37));首先会通过链表查找到控制器，然后调用控制器的get函数或去寄存器的值。后来发现编译时会自动生成gpiolib库的头文件：123456789include/asm-generic/gpio.hstatic inline int gpio_direction_input(unsigned gpio)&#123; return gpiod_direction_input(gpio_to_desc(gpio));&#125;static inline int gpio_direction_output(unsigned gpio, int value)&#123; return gpiod_direction_output_raw(gpio_to_desc(gpio), value);&#125;4.小结开始提了3个问题驱动开发中的GPIO API 究竟是怎么实现的？这里我们花了大力气阅读了芯片手册和源码.重点关注了三个问题 gpio-mxc.c gpio-genric.c gpiolib.cgpio-mxc 重点在维护的结构体mxc_gpio_port。最重要的两个结构：struct bgpio_chipstruct gpio_chip gc;1234567891011121314151617181920212223242526struct mxc_gpio_port &#123; struct list_head node; void __iomem *base; int irq; int irq_high; struct irq_domain *domain; struct bgpio_chip bgc; u32 both_edges;&#125;;struct bgpio_chip &#123; struct gpio_chip gc; unsigned long (*read_reg)(void __iomem *reg); void (*write_reg)(void __iomem *reg, unsigned long data); void __iomem *reg_dat; void __iomem *reg_set; void __iomem *reg_clr; void __iomem *reg_dir; int bits; unsigned long (*pin2mask)(struct bgpio_chip *bgc, unsigned int pin); spinlock_t lock; unsigned long data; unsigned long dir;&#125;;通过bgpio_init() 完成了对struct bgpio_chip的初始化，尤其是和gpiolib交互的重要数据结构struct gpio_chip,至此完成对寄存器操作的抽象.最后使用gpiolib_add()将我们的GPIO控制器加入到了gpiolib.c的控制器链表中，完成了gpiolib库的封装GPIO的中断又是怎么实现的？我们分析一部分代码，中断函数的注册和当中断发生后如何区分是哪个IO口发生的中断，中断控制器的实现我们还没分析到，相信后面分析会将这个流程连接起来。GPIO号和IRQ的号码怎么映射的？中断号和IO后映射问题,关键在函数irq_find_mapping中，我们暂时还没有跳转过代码去研究这一部分。]]></content>
      <categories>
        <category>编程珠玑</category>
        <category>源码分析</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>编程珠玑</tag>
        <tag>Linux</tag>
        <tag>GPIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银翼杀手]]></title>
    <url>%2Fmovie%2Fblade-runner.html</url>
    <content type="text"><![CDATA[我所见过的事物，你们人类绝对无法置信。我目睹了战船,在猎户星座的边缘中弹，燃起熊熊火光。我看着C射线,划过了唐怀瑟之门那幽暗的宇宙空间。那所有的时光都将湮没在时间的洪流中……始This was not called excution, It was called retirement.全文凄冷的基调的开始18年第一部电影《银翼杀手2049》。没想到一发不可收，呼啸着看完这个系列，沧桑的美感,忧郁的气质，几番离经叛道以及人性的探讨与自我沉思使我沦陷。主线剧情之外，更是饶有趣味的拓展了整个世界。故事的起源《银翼杀手》[1982]一部老片，故事发生在2019年，也就是2049中上一代银翼杀手与”连锁六型”复制人之间的纠葛。整个故事是回应了Deckard提出问题：六型复制人为何要冒着被杀的危险回到地球，回到创造他们的泰瑞公司。忽然间发现倒叙的方式来看故事，是另一种趣味，有一种解密的愉悦。观影顺序导演很贴心的另外拍了三个短片来介绍（总计20分钟左右），可以在观看2049前了解一下。《银翼杀手：2022黑暗浩劫》 关于大断电事件,8代复制人的反叛，最终导致复制人禁的产生。《银翼杀手：2036复制人黎明》 复制人禁令解除，也就是2049中的最新的复制人《银翼杀手：2048无处可逃》 2049世界环境的铺垫。我推荐的观影推荐顺序：银翼杀手：2022黑暗浩劫银翼杀手：2036复制人黎明银翼杀手：2048无处可逃银翼杀手2049银翼杀手 (经典往往要最后看)人物K2049的主角人生充满戏剧性，几经人生颠覆，到头却是一场空，画面最终定格在苍茫的雪。从任人唾弃的杀手到命运之子,接着女友消失,最终幻想破灭真相大白，人生何不过一场虚无缥缈的梦，梦醒时分才发现自己两手空空。可曾想近乎孪生的复制人与人截然不同的两种命运，前者艰难的触碰真实的世界，后者却真实活在想象中。世界之所以美好，因为我们见过衰败，见过沧桑。K的最美好回忆莫过于他的虚拟女友着一席旗袍时的惊艳站在枯树旁若突兀的景色废墟中孤独的背影最后是雪中怅然的印记Rachael我想Rachael是爱Deckard的，而不仅仅是2049所说仅仅是场安排。虽然戏份很少，可是能看出来于Deckard之间的感情。华丽的照片镇楼Deckard上一代银翼杀手Deckard，无从得知他是否为复制人。与Rachel霸气的对话情景，荡气回肠。或许这才是壁咚的始祖.Deckard: Now you kiss me!Rachael: I can’t rely on my…Deckard: Say kiss me !Rachael: Kiss me !Deckard: I want you!Rachael:I want youI want youPut your hangs on meRoy BattyI’ve seen things you people wouldn’t believe.我所见过的事物，你们人类绝对无法置信。Attack ships on fire off the shoulder of Orion.我目睹了战船,在猎户星座的边缘中弹，燃起熊熊火光I’ve watched c-beams glitter in the dark near the Tannhauser Gate.我看着C射线,划过了唐怀瑟之门那幽暗的宇宙空间All those … moments will be lost in time,那所有的时光都将湮没在时间的洪流中。 like tears…in rain.就像眼泪…消逝在雨中Time to die……..死亡的时刻…到了“连锁六型”复制人领袖Roy,用这样一段气势恢弘的悲情告白,作为弥留之际对世界的拷问。先写到这里困=_=#.你们都逃不过我的眼睛!]]></content>
      <categories>
        <category>我思故我在</category>
        <category>影视杂谈</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>电影</tag>
        <tag>悲剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年]]></title>
    <url>%2Fdiary%2F2018-1-2.html</url>
    <content type="text"><![CDATA[梦想总有三头六臂，画在纸上的张牙舞爪倾刻只剩残垣断壁。张望过去，不想，退的过猛，尽是些孩童的记忆。慌张的掐着脉搏才寻到一些踪迹。也许是上个年头的记忆太过平淡，大脑的压缩便有了用武之地。有时候会想我的生活应该是这样的，可却总是妥协于时光的流逝。使劲的想出去年的几个关键字，大抵是：困，闲，药，妙。困于情而闲于事，加上一个药罐子真是奇了怪了。我发现我害怕过一种趋于平静的日子，不知道是折腾惯了，还是内心不甘心与此。平淡的生活会消磨意志，内心对话也越来越少，所以留下的印记也就不多了。跳出来了也就想明白，内心的孤寂还需保持。至于药罐子，仅是不幸灌了几味迷魂汤药，却想着什么灵丹妙药，不过一计泻药，就此作罢。妙指满心欢喜妙然小师妹。常与之叽里呱啦，呲牙咧齿，内心被暖到渐渐被融化。常作此想，我只愿蓬勃的生在此时此刻，多好。嗯，一晌贪欢。年末的时候，世界观被哲学史刷新了一次。这是很多年再未有过的感觉，一种很微妙的探索。很多曾经的想法被联系起来，思绪便潮湿又雀跃。我们生下来为了就是寻找良质，寻求自我。我们每个人都拥有信仰，只是当下信仰变得多元化，而不仅仅停留在宗教的层面，可能是世界观，所以不轻易察觉。我们相信许多假说，如生物进化论，唯物辩证法。我们没办法推倒它，它又是那么合理，最后悄悄的钻进脑里，化作行动的指定。本质上与印第安人相信鬼魂如出一辙。我想，生活这样便好，不需要用年这个奇怪的度量单位来引起共鸣。说是冷眼旁观也罢，我只愿蓬勃的生在此时此刻。]]></content>
      <categories>
        <category>我思故我在</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>我思故我在</tag>
        <tag>生活感悟</tag>
      </tags>
  </entry>
</search>
